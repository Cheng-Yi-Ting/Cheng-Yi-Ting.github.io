{"meta":{"title":"Cyting","subtitle":null,"description":null,"author":"Cheng Yi Ting","url":"https://cheng-yi-ting.github.io","root":"/"},"pages":[{"title":"","date":"2020-01-10T11:59:09.344Z","updated":"2018-01-26T06:41:06.000Z","comments":true,"path":"404.html","permalink":"https://cheng-yi-ting.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2020-01-10T11:59:09.345Z","updated":"2018-01-26T06:41:06.000Z","comments":true,"path":"README.html","permalink":"https://cheng-yi-ting.github.io/README.html","excerpt":"","text":"hexo-theme-hiero SampleHi, this is hexo-theme-hiero sample website. You can click here(https://itimetraveler.github.io/hexo-theme-hiero) to visit."},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-26T06:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://cheng-yi-ting.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2018-01-26T06:41:06.000Z","comments":true,"path":"about/index.html","permalink":"https://cheng-yi-ting.github.io/about/index.html","excerpt":"HipaperA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档","text":"HipaperA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档 Installation Get it from GitHub 1$ git clone https://github.com/iTimeTraveler/hexo-theme-hipaper.git themes/hipaper Enable Modify theme setting in _config.yml to hipaper. 1234# Extensions## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: http:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: hipaper Update 12$ cd themes/hipaper$ git pull FeaturesLogo: Image or TextYou can set a image as your logo instead of original text title. Like this: just enable avatar field in hipaper/_config.yml. 12345678# Put your avatar.jpg into `hexo-site/themes/hipaper/source/` directory.# url is target link (E.g. `url: https://hexo.io/logo.svg` or `url: css/images/mylogo.jpg`)avatar: enable: true width: 124 height: 124 bottom: 10 url: https://hexo.io/logo.svg Code HighlightHipaper use Tomorrow Theme for your code block. We have six options in total: default, normal, night, night blue, night bright, night eighties Above preview picture is default theme. the image below show other five Highlight themes. Modify highlight_theme in hipaper/_config.yml. 12345# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting.Hipaper provides 7 built-in widgets: search social recent_posts category tag tagcloud archive All of them are enabled by default. You can edit them in widget setting. SearchHipaper use Insight Search to help you search anything inside your site without any third-party plugin. 12345# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false Attention: You need to install hexo-generator-json-content before using Insight Search. 1$ npm install -S hexo-generator-json-content FancyboxHipaper uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; Comment supportHipaper has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to Hipaper hipaper/_config.yml: 123# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname: Browser support ContributingAll kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. Looking forward to your pull request. Special thanks to ATHEMES, who designed the original theme FASHIONISTA for Wordpress. LicenseHipaper is under the MIT license. See the LICENSE file for details."},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-26T06:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"https://cheng-yi-ting.github.io/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-26T06:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"https://cheng-yi-ting.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo 備份","slug":"2020-02-08-HexoBackup","date":"2020-02-07T16:00:00.000Z","updated":"2020-02-08T07:42:07.158Z","comments":true,"path":"2020/02/08/2020-02-08-HexoBackup/","link":"","permalink":"https://cheng-yi-ting.github.io/2020/02/08/2020-02-08-HexoBackup/","excerpt":"","text":"我們在使用 Hexo 網誌框架時，會事先在 GitHub 上新增 GitHub Pages 來完成 Blog 搭建，透過輸入 hexo g -d 進行部署，所產生的是靜態網頁並發布在網站上，不過卻沒有備份到 .md 檔案，這樣我們辛辛苦苦寫的文章卻沒有備份到。所以本篇將會說明如何將我們所撰寫的文章，及相關的配置設定一同備份至 GitHub ，這樣當原始檔案遺失時才有機會進行還原，而不是只有 Hexo 所產生出的靜態檔案。 每次透過 hexo g -d 後 master 會儲存 Blog 的靜態檔案。 分支建立因為需要要儲存其它的檔案，所以要先在自己的 GitHub Pages 的 Repository 上建立一個新的分支， Repository 名稱為 username.github.io ，當然你也可以存在別的 Repository 。一開始只會有 master 分支，而這邊示範為在原本的 Repository 上新增 backup 分支。 步驟初始化這個目錄，進行版本控制。 1git init 建立新分支 backup ： 1git checkout -b backup Hexo 本身在 .gitignore 中排除了不需要上傳的檔案，所以直接 git add. 即可： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules&#x2F;public&#x2F;.deploy*&#x2F; 將檔案加至暫存區及儲存庫： 12git add .git commit -m &quot;Commit update&quot; 設定要推上遠端 GitHub Server 的節點： 1git remote add origin git@github.com:username&#x2F;username.io.git 可以使用 npm scripts 來執行上面重複的命令： 12345&#123; &quot;scripts&quot;: &#123; &quot;b&quot;: &quot;git add . &amp;&amp; git commit -m \\&quot;Commit update\\&quot; &amp;&amp; git push origin master:backup&quot; &#125;&#125; 每行命令用 &amp;&amp; 符號來分開執行。 之後就可以透過輸入 npm run b 來佈署 .md 檔、主題及相關配置： 1npm run b 當切換至分支 backup 後就會看到原本在本地的檔案。 git-backup除了上述方法以外，也可以使用 hexo-git-backup 套件來備份檔案： 安裝套件： 1npm install hexo-git-backup --save _config.yml 檔案設定： 12345backup: type: git repository: github: git@github.com:username&#x2F;username.git,branchName gitcafe: git@github.com:username&#x2F;username.git,branchName 執行備份： 1hexo backup 或 1hexo b 如果想連主題一起備份的話，可新增 theme 欄位： 123456backup: type: git theme: coney,landscape,xxx repository: github: git@github.com:username&#x2F;username.git,branchName gitcafe: git@github.com:username&#x2F;username.git,branchName 如果想要更改 commit 訊息的話，可新增 message 欄位： 123456backup: type: git message: Commit update repository: github: git@github.com:xxx&#x2F;xxx.git,branchName gitcafe: git@github.com:xxx&#x2F;xxx.git,branchName 參考文獻 Hexo 備份 md 檔 - 《Chris 技術筆記》 Hexo備份至GitHub | 大专栏","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://cheng-yi-ting.github.io/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://cheng-yi-ting.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://cheng-yi-ting.github.io/tags/GitHub/"}]},{"title":"JavaScript - 音樂播放器","slug":"2020-02-01-JavaScript-28","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T06:10:57.919Z","comments":true,"path":"2020/02/02/2020-02-01-JavaScript-28/","link":"","permalink":"https://cheng-yi-ting.github.io/2020/02/02/2020-02-01-JavaScript-28/","excerpt":"","text":"此範例程式碼同步於 CodePen 及 GitHub 。 本文教學如何使用 JavaScript 實作簡易音樂播放器，首先建立一個 music 資料夾並將要播放的影音檔放至此資料夾，此範例音樂來源為 youtube Audio Library 無版權音樂。 製作歌曲選單列表首先將 music 資料夾內的音樂檔名列出，利用 ul 及 li 來製作條列式選單： 1234567&lt;ul id=\"musicSources\"&gt; &lt;li&gt;Slug_Love_87&lt;/li&gt; &lt;li&gt;Mosquito_Mojito&lt;/li&gt; &lt;li&gt;Groove_Tube&lt;/li&gt; &lt;li&gt;Loose_Slip&lt;/li&gt; &lt;li&gt;Flutes&lt;/li&gt;&lt;/ul&gt; 將 ul 設定 margin-left 與 padding-left 為 0 來取消 ul 左邊的外距與內距，防止 ul 內縮； li 加上 list-style-type:none; 來取消符號顯示。 1234567891011121314151617ul &#123; background-color: rgb(0, 0, 0); margin-left: 0; padding-left: 0; color: #ffffff;&#125;li &#123; list-style-type: none; line-height: 30px; border-bottom: 1px solid rgb(0, 0, 0);&#125;li:hover &#123; background-color: rgb(71, 71, 71); cursor: pointer;&#125; 以上語法會產生如下表格： 事件委派（ Event Delegation）如果要替每個 li 都綁定 click event hander ，可以使用 for 迴圈來綁定，也就是有幾個 li 就要加幾次 addEventListener ，之後在新增歌曲還要在綁定一次事件，讓程式碼複雜化。 過去有介紹過瀏覽器事件的運作原理: DOM - 事件處裡及傳遞機制 ，我們可以將 click 事件綁定在 parent 上，藉由 Event Bubbling 來傳遞給 child ，而非直接將事件綁定在 child 上，可以減少監聽器的數量，只要判斷目標(e.target)是哪個項目再去執行即可。 123456789101112131415161718192021window.addEventListener('load', () =&gt; &#123; let musicSources = document.querySelector('#musicSources'); musicSources.addEventListener('click', musicTarget = (e) =&gt; &#123; if (e.target.tagName.toLowerCase() === 'li') &#123; if (document.querySelector(\".musicSpan\")) &#123; document.querySelector(\".musicSpan\").remove(); &#125; if (document.querySelector(\"audio\")) &#123; document.querySelector(\"audio\").remove(); &#125; let target = e.target; //取得按下的歌曲(li) const pn = target.innerText; //取得歌曲名稱(文字內容) let span = document.createElement('span') //建立span元件 span.className = 'musicSpan'; //指定class名稱 span.innerHTML = '4'; //指定span裡的文字(4表示三角形符號) target.appendChild(span); //放入li元件 playMusic(pn); //播放音樂 &#125; &#125;);&#125;) 我們將 click 事件綁定在 id 為 musicSources 的 ul 上，再利用 e.target.tagName 判斷是不是 li 就可以了，讓程式碼簡潔許多，之後如果新增歌曲一樣會綁定 click 事件。 當按下歌曲時，歌曲前方顯示一個三角形符號這裡使用 Webdings 字型來產生三角形符號。首先指定字型 font-family: Webdings; ，輸入 4 就是使用三角形符號，在將文字放在 span 內即可。 1234567let target = e.target; //取得按下的歌曲(li)const pn = target.innerText; //取得歌曲名稱(文字內容)let span = document.createElement('span') //建立span元件span.className = 'musicSpan'; //指定class名稱span.innerHTML = '4'; //指定span裡的文字(4表示三角形符號)target.appendChild(span); //放入li元件playMusic(pn);//播放音樂 播放音樂建立 audio 元件並指定路徑來源為 music 資料夾： 1234567function playMusic(a) &#123; let myAudio = document.createElement('audio');//建立audio元件 myAudio.setAttribute(\"src\", \"music/\" + a + \".mp3\");//src 音檔路徑，a為傳入的歌曲名稱 myAudio.setAttribute(\"controls\", \"controls\"); //顯示撥放器 bottom.appendChild(myAudio); //加入在id名稱為bottom的元件裡 myAudio.play(); //播放音樂&#125; 當點擊歌曲時就新增一個 audio 元素，點擊其它歌曲時再將原本的 audio 元素移除，暫停和跳轉可以使用 audio 內建的功能。 隨機播放右上角建立隨機播放按鈕，同樣使用 Webdings 字型來產生樣式： 1&lt;span id=\"random\" title=\"隨機播放\" onclick=\"randomPlay()\"&gt;~&lt;/span&gt; 當點擊按鈕呼叫 randomPlay() 函式，使用 random() 來產生 0~4的整數值，將值帶入 li 標籤的 index ，接著再執行 click 事件就會執行播放音樂程式碼： 12345function randomPlay() &#123; let num = Math.floor(Math.random() * 5); //隨機數0~4 let randomLi = document.querySelectorAll('li')[num]; //將值帶入 li 的 index randomLi.click(); //觸發click事件&#125; 完整範例執行結果： 參考文獻 JavaScript 精選16堂課：網頁程式設計實作","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"https://cheng-yi-ting.github.io/tags/HTML5/"},{"name":"Event Delegation","slug":"Event-Delegation","permalink":"https://cheng-yi-ting.github.io/tags/Event-Delegation/"},{"name":"Audio","slug":"Audio","permalink":"https://cheng-yi-ting.github.io/tags/Audio/"}]},{"title":"Web Storage","slug":"2020-01-28-JavaScript-27","date":"2020-01-31T16:00:00.000Z","updated":"2020-02-01T13:37:10.683Z","comments":true,"path":"2020/02/01/2020-01-28-JavaScript-27/","link":"","permalink":"https://cheng-yi-ting.github.io/2020/02/01/2020-01-28-JavaScript-27/","excerpt":"","text":"在介紹什麼是 Web Storage 之前，讓我們來瞭解一下 HTTP COOKIES 的作用。 HTTP COOKIESClient 和 Server 透過 HTTP 協定來進行通訊，但是 HTTP 是無狀態協定(Stateless Protocol)，也就是說每次 Client 對 Server 發出的請求都是獨立的，每一次的請求都無法得知上一次請求的內容與資訊。 我們可以透過 cookie 把 server 所傳送過來的一些資料保存在 Client ，Cookie 常用於會員登入、購物車資訊、使用者設定偏好。 當使用者第一次登入網站， Server 就能將登入的相關資訊進行加密並儲存在 Client 的硬碟或記憶體中，之後 Cleint 發送 request 到 Server 就會附上 Cookie ， Server 就可以直接讀取來減少使用者重複輸入資料的行為。 Web Storage 概念Web Storage 是 HTML5 的新規範，一種將少量資料儲存於 Client 端的技術，只要支援 Web Storage API 規格的瀏覽器，都能透過 JavaScript 操作。 過去 Cookie 只允許每個網站儲存 4KB 的資料，而 Web Storage 可以儲存 1MB ~ 5MB 。 Cookie 在每個 HTTP request 送出時都會被傳送到 Server ，不管有沒有使用到 Cookie 中的資訊，在某種程度上會降低執行的效能與浪費網路頻寬，而且 Cookie 如果沒有加密則不適合放入重要的資訊。 Web Storage 的存取都是在 Client ，與 Cookie 一樣都是使用 key / value 的儲存格式，不會像 Cookie 一樣，隨著 request 發送給 Server 端，因為 Web Storage 只作用在 Client 端瀏覽器，並不會占用頻寬和影響網站效能。 Web Storage 分兩種，一個是 sessionStorage，另一個是 localStorage，兩者主要差別在於生命週期和有效範圍的不同。 localStorage 不會隨著瀏覽器關閉而消失，適合用在需要跨分頁或跨視窗的場合，除非手動清除資料不然關閉瀏覽器後資料還是會一直存在； sessionStorage 則是頁面關閉後資料就會消失，資料只對當前頁面有效，適合用在資料暫時保存的場合。 cookie、localStorage、sessionStorage 異同表 類型 cookie localStorage sessionStorage 大小 4KB 一般為 5MB 一般為 5MB 生命週期 過期或是執行刪除指令才會消失 執行刪除指令才會消失 頁面關閉後會消失 有效範圍 同一網站的網頁都可以存取 同一網站的網頁都可以存取 只有在單一分頁能存取 儲存格式 key / value key / value key / value 連線到 Server 時會自動帶上 會 不會 不會 安全性 較低 較高 較高 瀏覽器支援 Web Storage可以透過以下方式來判斷瀏覽器是否支援 Web Storage： 12345if (typeof(Storage) !== \"undefined\") &#123; // Code for localStorage/sessionStorage.&#125; else &#123; // Sorry! No Web Storage support..&#125; localStorage由於同源政策(Same-origin policy)限制，只能存取相同網站的 local storage。 所謂同源是指協定、主機(domain與ip)、埠號 (port) 都必須相同。例如我們有一個網址：http://www.cyting.com/image/page.html ，來判斷下列何者屬於同源： 網址 結果 原因 http://www.cyting.com/image/activity.html 同源 http://www.cyting.com/image/dir/web.html 同源 https://www.cyting.com/prod.html 不同源 協定不同 http://www.cyting.com:8001/dir/region.html 不同源 埠號不同 http://cyting.demo.com/dir/store.html 不同源 主機不同 在 HTML5標準，Web Storage 只允許儲存字串資料，存取方式有以下三種： setItem &amp; getItem儲存一個 localStorage 變數 userName ，並指定它的值為 Cyting 。 12let name = \"Cyting\";localStorage.setItem('userName',name); 使用 getItem 讀取資料： 1let value = localStorage.getItem(userName); // Cyting 陣列索引儲存語法： 12let name = \"Cyting\";localStorage.[\"userName\"] = name; 讀取語法： 1let value = localStorage.[\"userName\"]; 屬性儲存語法： 12let name = \"Cyting\";localStorage.userName = name; 讀取語法： 1let value = localStorage.userName; 刪除 localStorage透過呼叫 removeItem 或是 delete 來刪除 localStorage。 123localStorage.removeItem(\"userName\")delete localStorage.userName;delete localStorage[\"userName\"]\"; 如果是想清除 localStorage 的全部資料，可以使用 clear() 方法。 1localStorage.clear(); localStorage 實例程式碼同步於CodePen 使用者輸入姓名後可點擊「儲存至local storage」按鈕將資料儲存起來，當點擊「從local storage讀取資料」時就會讀取剛才輸入的姓名並輸出在頁面上，而「清除local storage資料」按鈕會將儲存的資料進行清空。 12345678&lt;body&gt; &lt;br /&gt; 請輸入您的姓名： &lt;input type=\"text\" id=\"inputname\" value=\"\"&gt;&lt;br /&gt; &lt;div id=\"show_LocalStorage\"&gt;&lt;/div&gt;&lt;br /&gt; &lt;button id=\"btn_save\"&gt;儲存至local storage&lt;/button&gt; &lt;button id=\"btn_load\"&gt;從local storage讀取資料&lt;/button&gt; &lt;button id=\"btn_clear\"&gt;清除local storage資料&lt;/button&gt;&lt;/body&gt; 123456789101112131415161718192021222324252627window.addEventListener('load', () =&gt; &#123; if (typeof(Storage) == \"undefined\") &#123; alert(\"您的瀏覽器不支援Web Storage\"); &#125; else &#123; btn_save.addEventListener(\"click\", saveToLocalStorage); btn_load.addEventListener(\"click\", loadFromLocalStorage); btn_clear.addEventListener(\"click\", clearLocalStorage); &#125;&#125;)function saveToLocalStorage() &#123; localStorage.username = inputname.value; show_LocalStorage.innerHTML = \"儲存成功!\";&#125;function loadFromLocalStorage() &#123; if (localStorage.username) &#123; show_LocalStorage.innerHTML = \"歡迎 \" + localStorage.username + \" !\"; &#125; else &#123; show_LocalStorage.innerHTML = \"暫無資料\"; &#125;&#125;function clearLocalStorage() &#123; localStorage.clear(); loadFromLocalStorage();&#125; 當使用者將瀏覽器關閉仍可以成功讀取資料，因為儲存在 local storage 的資料不會因為關閉瀏覽器而消失。 sessionStoragesessionStorage 只能保存在單一的瀏覽器視窗或分頁上，瀏覽器一關閉儲存的資料就會消失，主要是用於保存一些臨時的資料，避免使用者重整頁面的時候資料就不見了。使用 sessionStorage 語法與 localStorage 相同。 儲存： 1234let name = \"Cyting\";sessionStorage.setItem('userName',name);sessionStorage.[\"userName\"] = name;sessionStorage.userName = name; 讀取： 123let value = sessionStorage.getItem(userName);let value = sessionStorage.[\"userName\"];let value = sessionStorage.userName; 清除： 123sessionStorage.removeItem(\"userName\")delete sessionStorage.userName;delete sessionStorage[\"userName\"]\"; 如果是想清除 sessionStorage 的全部資料，可以使用 clear() 方法： 1sessionStorage.clear(); 參考文獻 JavaScript 精選16堂課：網頁程式設計實作 Day20 localStorage、sessionStorage Cookie、LocalStorage、SessionStorage 差異 [筆記] HTTP Cookies 和 Session 使用 [不是工程師] Cookie 是文檔還是餅乾？簡述HTTP網頁紀錄會員資訊的一大功臣。 [HTML5]簡述HTML5的Client端暫存-localStorage/sessionStorage [Html 5] WebStorage - localStorage和sessionStorage","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"https://cheng-yi-ting.github.io/tags/HTML5/"}]},{"title":"JavaScript - Async/Await","slug":"2020-01-19-JavaScript-26","date":"2020-01-22T16:00:00.000Z","updated":"2020-01-23T09:33:55.586Z","comments":true,"path":"2020/01/23/2020-01-19-JavaScript-26/","link":"","permalink":"https://cheng-yi-ting.github.io/2020/01/23/2020-01-19-JavaScript-26/","excerpt":"","text":"Async functions在上一篇中我們提到了 Promise ，避免使用多層 callback 所造成程式碼難以維護的問題。而 ES7 提供了 async/await 語法，可以看成是 Promise 的語法糖，更方便的寫出非同步程式碼。 async 所宣告的函式，會回傳一個 Promise ，使用方法就是在宣告的函式前增加 async 關鍵字，說明這是一個非同步的函式。 下面的範例相當於回傳一個 resolved promise： 123async function f() &#123; return 1;&#125; 也可以寫成這樣： 123async function f() &#123; return Promise.resolve(1);&#125; Awaitawait 只能在 async 函式中使用，否則會拋出 syntax error 。 await 表示等待 Promise 的狀態為 resolve 或 reject 才會繼續執行函式，讓我們看一下例子： 123456789101112async function main() &#123; let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(\"done!\"), 1000) &#125;); let result = await p; // 等待 promise resolves console.log(result); // \"done!\"&#125;main(); 範例中的程式會等待 p 一秒鐘後才會進行輸出。 下面為一個簡易的 async/await 例子： 123456789101112131415161718function p(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; value++ resolve(value) &#125;, 1000) &#125;)&#125;async function main() &#123; let x1 = await p(1); let x2 = await p(2); let x3 = await 3; console.log(x1 + x2 + x3); // 8&#125;main(); 因為 async 函式相當於回傳一個 Promise ，所以我們一樣可以用操作 Promise Chain 的方式，把 Promise 一層一層的往下傳： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546async function main() &#123; console.log(\"Start main function\" ); let x1 = await p1(1); // 2 let x2 = await p2(2); // 4 let x3 = await 3; // 3 await p2(4); // 6 return x1 + x2; // 6&#125;main().then(value =&gt; &#123; return value + 2 ; // 8&#125;).then(p1).then((value) =&gt; &#123; console.log(value); // 9&#125;).catch((error) =&gt; &#123; console.log('error:', error)&#125;)function p1(value) &#123; console.log(\"P1 value is :\" + value); return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; value++ resolve(value) &#125;, 1000) &#125;)&#125;function p2(value) &#123; console.log(\"P2 value is :\" + value); return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; value+=2 resolve(value) &#125;, 1000) &#125;)&#125;/*Output:Start main functionP1 value is :1P2 value is :2P2 value is :4P1 value is :89/* await 可以搭配 Promise.all 和 Promise.race 來使用： 123456789101112131415161718192021async function main() &#123; console.log(\"Start main function\" ); const [x1, x2] = await Promise.all([p(1000), p(2000)]); const x3 = await Promise.race([p(1000), p(2000), p(3000)]); return x1 + x2 + x3; // 4000&#125;main().then(value =&gt; &#123; console.log(`value is $&#123;value&#125;`);&#125;)function p(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; if (value &lt; 1000 )&#123; reject('Unexpected condition') &#125; resolve(value) &#125;, value) &#125;)&#125; 錯誤處理錯誤處理的方式使用 try / catch ： 12345678910111213141516171819202122const isEven = (num) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (num % 2 == 0) &#123; resolve('even'); &#125; else &#123; reject('odd'); &#125; &#125;);&#125;const verify = async (num) =&gt; &#123; try &#123; const sign = await isEven(num); console.log(sign); &#125; catch (err) &#123; console.log(err); &#125;&#125;verify(8); // evenverify(15); // oddverify('Ian'); // odd 只用 catch 也行： 123456const verify = async (num) =&gt; &#123; const sign = await isEven(num); console.log(sign);&#125;verify('Ian').catch(err =&gt; console.log(err)); // odd 如果是採用以下的寫法，因為 await isEven(15) 的結果會是 reject ，所以在 x2 就會進入到 catch ，表示後面的 x3 就不會執行： 123456789101112131415161718192021222324const isEven = (num) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; if (num % 2 == 0) &#123; resolve('even'); &#125; else &#123; reject('odd'); &#125; &#125;);&#125;const verify = async () =&gt; &#123; const x1 = await isEven(8); const x2 = await isEven(15); const x3 = await isEven('Ian'); return x1&#125;verify() .then((value) =&gt; &#123; console.log(value) &#125;) .catch((error) =&gt; &#123; console.log('error:', error)&#125;) async/await and promise.then/catch透過在 await 我們就可以很容易的控制非同步執行， 再搭配 try / catch 來處理例外狀況，因為在全域環境中無法使用 await ，所以這時候就可以透過 .then / catch 來控制整個流程。 參考文獻 [JS] Async and Await in JavaScript | PJCHENder 私房菜 JS 原力覺醒 Day16 - Async / Await：Promise 語法糖 Day25 優雅的 Await、Async Async/await How to use async/await in JavaScript","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"ES7","slug":"ES7","permalink":"https://cheng-yi-ting.github.io/tags/ES7/"}]},{"title":"JavaScript - Promise","slug":"2020-01-11-JavaScript-25","date":"2020-01-17T16:00:00.000Z","updated":"2020-01-23T00:08:41.950Z","comments":true,"path":"2020/01/18/2020-01-11-JavaScript-25/","link":"","permalink":"https://cheng-yi-ting.github.io/2020/01/18/2020-01-11-JavaScript-25/","excerpt":"","text":"過去以 Callback 撰寫非同步會容易在呼叫多層之後產生「Callback Hell」難以維護的問題，而 ES6 提供 Promise 來更方便的執行非同步。關於 JavaScript 執行方式、非同步及 Callback 原理解釋請參考前文： JavaScript 非同步執行 （Ascynchronous） JavaScript - Call Stack , Event Queue &amp; Event Loop JavaScript Callback Function 在還沒有 Promise 的時候，我們為了控制多個函式間執行的順序，就會透過 Callback 的形式將 function 當作參數傳進去： 12345678910111213141516171819// 為了確保先執行 first 再執行 second// 我們在 first 加上 callback 參數var first = function(callback)&#123; setTimeout(function()&#123; console.log(\"This is first.\"); callback(); &#125;, 1000);&#125;;var second=function()&#123; console.log(\"This is second.\");&#125;;// 將 second 作為參數帶入 first()first(second);//\"This is first.\"//\"This is second.\" 無論 first() 在執行的時候要等多久， second() 都會等到 first() 執行完才會執行。也可以寫成下面這樣： 12345678910111213141516function first(callback) &#123; setTimeout(() =&gt; &#123; console.log(\"This is first.\"); callback() &#125;, 1000)&#125;function second(callback) &#123; callback(() =&gt; &#123; console.log(\"This is second.\"); &#125;)&#125;second(first)//\"This is first.\"//\"This is second.\" 如果再增加 Callback 的數量： 1234567891011121314151617181920212223242526272829303132function first(callback2) &#123; setTimeout(() =&gt; &#123; console.log(\"This is first.\"); callback2() &#125;, 1000)&#125;function second(callback) &#123; setTimeout(() =&gt; &#123; console.log(\"This is second.\"); callback() &#125;, 1000)&#125;function third() &#123; console.log(\"This is third.\");&#125;function main(callback) &#123; first(() =&gt; &#123; second(() =&gt; &#123; callback() &#125;) &#125;)&#125;main(third)//\"This is first.\"//\"This is second.\"//\"This is second.\" 當 Callback 太多層就會變成非常複雜的巢狀結構： 123456789first(() =&gt; &#123; second(() =&gt; &#123; third(() =&gt; &#123; fourth(() =&gt; &#123; // ...... &#125;) &#125;) &#125;)&#125;) Promise Promise 提供的新語法讓非同步更加直觀，讓我們看一下它的建構函式： 1new Promise( function(resolve, reject) &#123; ... &#125; ) 下面是箭頭函式的寫法： 1new Promise( (resolve, reject) =&gt; &#123; ... &#125; ) Promise 的狀態與流程Promise 有三種 state(狀態) pending：等待(還在執行中且結束狀態未知) resolved/fullfilled：完成/成功 rejected：拒絕/失敗 Promise 運作流程圖： 來源：MDN Promise 物件中包含兩個參數： resolve 與 reject ， then 會接收 resolve 的 value， catch 則接收 reject 的 value。 讓我們看一個基本的 Promise 範例： 123456789101112131415161718const p = new Promise(function(resolve, reject) &#123; setTimeout(function()&#123; let value = 1 console.log(value); resolve(value); &#125;, 1000); &#125;);//Promise fullfilled handlerp.then((value) =&gt; &#123; // 在 p 被 resolve 時執行 console.log('success:' + value)&#125;)//Promise rejected handlerp.catch((error) =&gt; &#123; // 在 p 被 reject 時執行 console.log('error:', error)&#125;) Pending當 Promise 沒有 resolve 或是 reject 的時候，程式將會一直處在 pending 狀態： 1234567var p = new Promise(function(resolve, reject) &#123;&#125;);p.then((value) =&gt; &#123; console.log('success');&#125;)p.catch((error) =&gt; &#123; console.log('error:', error);&#125;) 例如：送出一個請求一直沒有收到回應時， Promise 就會一直處於 pending 狀態。 Promise Chain我們可以在 Promise 使用 .then 來進行串接，透過在 .then 裡面 return 一個值，讓這個回傳值以 Promise 物件的形式傳到下一個 .then ，形成 Promise Chain： 123456789101112131415161718192021const p = new Promise(function(resolve, reject) &#123; setTimeout(function()&#123; let value = 1; resolve(value); &#125;, 1000); &#125;);p.then((value) =&gt; &#123; // 得到 resolve 內的值 console.log(value); // 1 return value+1;&#125;).then((value) =&gt; &#123; // 得到上一個 .then return 的值 console.log(value); // 2 return value+1;&#125;).then((value) =&gt; &#123; // 得到上一個 .then return 的值 console.log(value); // 3&#125;).catch((error) =&gt; &#123; console.log('error:', error)&#125;) catch 如果是串在中間，在 new Promise 的時候是 reject ，會導致前面 .then 都不會被執行: 123456789101112131415161718const p = new Promise(function(resolve, reject) &#123; setTimeout(function()&#123; let value = 1; reject(value); &#125;, 1000); &#125;);p.then((value) =&gt; &#123; console.log('Start'); return value+1;&#125;).catch((error) =&gt; &#123; console.log('error:', error)&#125;).then((value) =&gt; &#123; console.log('End'); &#125;)//error: 1//End Promise 使用範例我們可以在 .then 中 return 一個 new Promise 。 範例一： 1234567891011121314151617181920212223242526272829303132333435const p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; let value = 1; resolve(value) &#125;, 1000)&#125;)p.then((value) =&gt; &#123; console.log(\"This is the first value :\" + value); return value + 1&#125;).then((value) =&gt; &#123; console.log(\"This is the second value :\" + value); // return 一個 new Promise return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(value + 2) &#125;, 1000) &#125;)&#125;)// 等 Promise resolve 後才會執行。.then((value) =&gt; &#123; console.log(\"This is the third value :\" + value);&#125;).catch((error) =&gt; &#123; console.log('error:', error)&#125;)/*Output:This is the first value: 1This is the second value: 2This is the third value: 4/* 範例二： 123456789101112131415161718192021222324252627function p(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; value++ resolve(value) &#125;, 1000) &#125;)&#125;p(1) .then((value) =&gt; &#123; console.log(\"This is the first value :\" + value); return p(value+1) &#125;) .then((value) =&gt; &#123; console.log(\"This is the second value :\" + value); return p(value+1) &#125;) .then((value) =&gt; &#123; console.log(\"This is the third value :\" + value); &#125;)/*Output:This is the first value: 2This is the second value: 4This is the third value: 6/* 範例三： 123456789101112131415161718192021222324252627function p(value) &#123; console.log(\"This value is :\" + value); return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; value++ resolve(value) &#125;, 1000) &#125;)&#125;p(1) .then(p) .then((value) =&gt; &#123; console.log(value) return value+2 &#125;) .then(p) .catch((error) =&gt; &#123; console.log('error:', error)&#125;)/*Output:This value is :1This value is :23This value is :5/* 範例四： 12345678910111213141516171819202122232425262728const p = new Promise(function(resolve, reject) &#123; setTimeout(function()&#123; let value = 1; resolve(value); &#125;, 1000); &#125;);function funA (value) &#123; console.log(\"The value of function A is :\" + value); const data = funC(value) return data + 1&#125;function funB (value) &#123; console.log(\"The value of function B is :\" + value);&#125;function funC (value) &#123; return value + 2&#125;p.then(funA) .then(funB)/*Output:The value of function A is :1The value of function B is :4/* Promise 錯誤處理通常我們會將 .catch 放在最後面做錯誤處裡，當其中一個 .then 發生錯誤時，就會跳到 .catch ，而 .catch 之後的 .then 皆不會執行。 12345678910111213141516171819202122232425262728293031323334function p(value) &#123; return new Promise((resolve, reject) =&gt; &#123; if (value &gt; 2)&#123; reject('Unexpected condition') &#125; setTimeout(function() &#123; value++ resolve(value) &#125;, 1000) &#125;)&#125;p(1).then((value =&gt; &#123; console.log(\"This is the first value :\" + value); return p(value)&#125;)).then((value =&gt; &#123; console.log(\"This is the second value :\" + value); return p(value)&#125;)).then((value =&gt; &#123; console.log(\"This is the third value :\" + value); return p(value)&#125;)).catch((error) =&gt; &#123; console.log(error)&#125;)/*Output:This is the first value :2This is the second value :3Unexpected condition/* Promise.all Promise.all 可以傳入一個以上的 Promise 並同時執行，等到所有的 Promise 都回應狀態後，才會進入 .then 。 1234567891011121314151617181920function p(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; if (value &lt; 1000 )&#123; reject('Unexpected condition') &#125; resolve(value) &#125;, value) &#125;)&#125;Promise.all([p(1000), p(2000), p(3000)]).then((value)=&gt; &#123; console.log('This value is :', value);&#125;).catch( err =&gt; &#123; console.log(err)&#125;);/*[This value is : 1000 , This value is : 2000 , This value is : 3000]*/ 如果其中一個 Promise 中有出現 reject ，則直接進入 .catch 階段，而不會收到其他 Promise resolve 的回傳值。 Promise.racePromise.race 一樣可以傳入多個 Promise 並同時執行，但只回傳 Promise 中最快完成的，並接著執行 .then ，而其他的 Promise 皆不會執行。 1234567891011121314151617function p(value) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve(value) &#125;, value) &#125;)&#125;Promise.race([p(1000), p(2000), p(3000)]).then((value)=&gt; &#123; console.log('This value is :', value);&#125;).catch( err =&gt; &#123; console.log(err)&#125;);/*This value is : 1000*/ 參考文獻 callback, promise, async/await 使用方式教學以及介紹 Part I - Jack Yu | 傑克 [JS] Promise 的使用 | PJCHENder 私房菜 Day23 Promise 詳解(1/2) Day24 Promise 詳解(2/2) JavaScript - Promise (2) JS 原力覺醒 Day14 - 一生懸命的約定：Promise","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://cheng-yi-ting.github.io/tags/ES6/"}]},{"title":"JavaScript - Call Stack , Event Queue & Event Loop","slug":"2020-01-04-JavaScript-24","date":"2020-01-09T16:00:00.000Z","updated":"2020-01-23T00:08:27.385Z","comments":true,"path":"2020/01/10/2020-01-04-JavaScript-24/","link":"","permalink":"https://cheng-yi-ting.github.io/2020/01/10/2020-01-04-JavaScript-24/","excerpt":"","text":"JavaScript是同步執行的程式語言。 JavaScript 是一個設計為同步執行的程式語言，並且是單執行緒(single-threaded)。單執行緒可以想像成有一個餐廳的員工同時負責櫃檯和廚房的工作，他的能力強大到可以同時在兩份工作之間快速的切換，仿佛有多個員工在做事的錯覺。 竟然 JavaScript 不是非同步執行程式碼，那為什麼可以監聽瀏覽器的一些事件，像是移動滑鼠、點擊按鈕、捲動頁面、資料請求和檔案寫入這類型的非同步呼叫。 其實瀏覽器不是只有 JavaScript Engine 的存在 整個瀏覽器的運行環境並非只由 JS 引擎組成，瀏覽器還包含許多其他的部分，像是渲染引擎(Rendering Engine)和 HTTP 請求(Http Request)，而瀏覽器也提供 Web API 讓 JS 做應用，像是操作 DOM 節點 、 AJAX 請求、 setTimeout 計時、 Geolocation 地理位置。雖然 JS 引擎身是同步執行，但透過和瀏覽器的其他引擎互動來達到非同步的效果。 Call StackJS 的執行堆疊(call stack)記錄了 function 在 JS engine內的執行順序，意思就是程式目前執行到哪邊， call stack 是以同步的方式由上而下執行，採取後進先出 Last In, First Out (LIFO) ，最先執行的函式會被放在 stack 的最下面，如果在函式中執行了 return ，則會將該函式 pop out 出 stack 。 請參考以下範例： 123456789101112function foo() &#123; console.log(\"-&gt; start [foo]\"); console.log(\"&lt;- end [foo]\");&#125;function bar() &#123; console.log(\"-&gt; start [bar]\"); foo() console.log(\"&lt;- end [bar]\");&#125;bar(); 以下為範例各執行階段： bar() 會先被執行 bar() 印出 “start” foo() 執行，此時 bar() 仍然在執行中 foo() 印出 “start” foo() 印出 “end” foo() 結束執行 bar() 印出 “end” bar() 結束執行 Stack Overflow如果遞迴函式不斷呼叫自己而沒有一個中斷點，則會造成瀏覽器產生 stack error ： Event Queue前面有說過瀏覽器除了有 JS Engine 外還有許多 Web API 可做應用，這些第三方 API 可以與 JS 一起執行，當遇到需要執行 call back 時，則會使用非同步模式，先將這些函式放到 Web APIs 中，在繼續執行主程式，等到時間到或是事件被觸發的時候，再把 call back 推送到 Event Queue(事件佇列) 中，等到整個 JS 執行環境結束後(Call Stack 清空)，才依序呼叫 Event Queue 裡面的函式，採取先進先出 first in, first out (FIFO)。 請參考以下範例： 123456789101112131415161718192021function foo() &#123; console.log(\"-&gt; start [foo]\"); console.log(\"&lt;- end [foo]\");&#125;function bar() &#123; console.log(\"-&gt; start [bar]\"); console.log(\"&lt;- end [bar]\");&#125;function baz() &#123; console.log(\"-&gt; start [baz]\"); setTimeout(foo, 1000); setTimeout(bar, 1000); console.log(\"&lt;- end [baz]\");&#125;baz(); 以下為範例各執行階段： baz() 會先被執行 baz() 印出 “start” foo() 先放到 Web APIs ，等待1秒後移至 Event Queue 中。 bar() 先放到 Web APIs ，等待1秒後移至 Event Queue 中。 baz() 印出 “end” baz() 執行完成，call stack 清空 透過 Event Loop 機制選取 queue 中的 foo()。 foo() 印出 “start” foo() 印出 “end” foo() 執行完成，call stack 清空 透過 Event Loop 機制選取 queue 中的 bar()。 bar() 印出 “start” bar() 印出 “end” bar() 執行完成，call stack 清空 Event LoopJS 當事件發生時，並不是馬上執行指定的函式，而是將事件排入 Event queue ，接著會重複檢查 call stack 是不是空的？如果是空的，再去看 Event queue 中有沒有待執行的函式，有的話就將函式 pop out ，放入 call stack 中執行。 參考文獻 所以說event loop到底是什麼玩意兒？| Philip Roberts | JSConf EU [JS] 理解 JavaScript 中的事件循環、堆疊、佇列和併發模式（Learn event loop, stack, queue, and concurrency mode of JavaScript in depth） Day06 JS是同步還是非同步? JS 原力覺醒 Day13 - Event Queue &amp; Event Loop 、Event Table 非同步設計 Understanding the JavaScript call stack","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 非同步執行 （Ascynchronous）","slug":"2020-01-04-JavaScript-23","date":"2020-01-03T16:00:00.000Z","updated":"2020-01-04T14:44:56.230Z","comments":true,"path":"2020/01/04/2020-01-04-JavaScript-23/","link":"","permalink":"https://cheng-yi-ting.github.io/2020/01/04/2020-01-04-JavaScript-23/","excerpt":"","text":"同步執行 ( Scynchronous )如果我有很多個任務，同步就是讓每個任務按照順序依序進行，後面的任務必須等待前面的任務執行完成後才會執行。 以生活例子比喻的話，假如我在買電影，我要等到前面所有排隊的人買完之後才能輪到我，而排在我後面的人也要等到我完成買電影票這個動作之後，才能輪到他們。 以程式碼來說明的話，同步執行就表示程式會依照所寫的程式碼一行一行去執行，而順序都是前一個動作執行完才會去接著執行下一個動作。同步程式的設計模式看起來會比較比較直覺，常見的程式語言像是C、C++、Java皆是採用同步模式。 假設有一個同步程式如下： 123456789101112function func1() { console.log('func1');}function func2() { console.log('func2');}function func3() { console.log('func3');}func1(1); // \"func1\"func2(2); // \"func2\"func3(3); // \"func3\" 我們可以發現程式是照順序一行一行進行輸出。 非同步執行 ( Ascynchronous )像是在買電影的時候，如果前面排隊的人處理很久，就會造成後面所有人買電影票的時間拉長。 由於同步執行的設計模式，使得程式必須等待前一個步驟完成後才能繼續執行，如果前一個動作沒有完成就會無法進行下一個動作而造成阻塞。 而非同步模式則相反，後面的任務不用等待前面的任務完成，各自執行各自的任務。 當你去百貨公司吃飯的時候，你不需要等待其他人點完餐和吃完飯後才輪到你點餐，每個人都可以在拿到餐點的時候就可以吃了，並不需要等待其他人先吃完。如果你點的是一份較花時間的牛排，那我只點一杯飲料就可以優先拿到，而不需要等到你的餐點完成後才輪到我。 如果是以同步的方式去讀取資料，就會在資料回傳之前會持續進行等待的動作，直到確定資料已經讀取完成後才繼續進行下一個動作。 以非同步的方式讀取資料的話，在資料回傳之前我可以先做其他的事情，等待資料回傳後再進行通知。 讓我們用 setTimeout 來示範非同步執行： 12345678// Say \"Hello.\"console.log(\"Hello.\");// Say \"Goodbye\" two seconds from now.setTimeout(function() { console.log(\"Goodbye!\");}, 2000);// Say \"Hello again!\"console.log(\"Hello again!\"); 由於 setTimeout 並不會暫停程式的執行，所以會立即執行後面的動作，等待時間到了才會呼叫並執行函式裡面的內容。 所以輸出的結果依序為： Say “Hello”. Say “Hello again!” 程式等待兩秒鐘 Say “Goodbye!” AJAX Requests這個範例使用 jQuery 的 Ajax 來進行操作，我們在 button 上加入一個 click 事件，當使用者點擊後會送出 request ，請求成功後會呼叫 callback 並把結果存入 data 。 123456789101112$(document).ready(function(){ $(\"button\").click(function(){ let data; $.ajax({url: \"demo_test.txt\", success: function(result){ $(\"#div1\").html(result); data = result; }}); console.log(data); });}); 由於程式並不會等待取回資料後才繼續執行，而是會先執行 console.log(data) ，所以不管怎樣程式都會印出 undefined 。 我們可以透過 callback functions 來讓程式依照我們想要的順序執行，不知道什麼是 callback 的請參考之前的文章。 JavaScript Callback Function 非同步和同步傳統的網頁在使用者提交資料後（亦即對伺服器發出請求），必須等到伺服器回應並重新整理頁面後，才能繼續進行下一個動作，這段期間內使用者無法對該頁面進行任何的存取。而非同步請求允許使用者在發出請求到伺服器回應的期間內繼續使用頁面（例如：繼續操作網頁、輸入資料），等到完成回應，網頁僅對部份資訊進行更新，藉以達到更有效的即時互動，非同步的核心精神在於減少等待，讓執行緒同時處理更多作業藉以提升產能。 如果網站是採取同步執行的設計模式，當我請求某一個網頁資料時，在資料回傳後才能進行下一個步驟，中途如果網頁無法回應或是阻塞住了，整個網站就會卡住。 若網站是採取非同步執行，等待資料回傳的同時還是能進行其他應用，假使資料無法成功存取也不會影響到其他正常功能的操作。 參考文獻 https://www.pluralsight.com/guides/introduction-to-asynchronous-javascript https://www.ithome.com.tw/node/74544 https://ithelp.ithome.com.tw/articles/10197312 https://blog.xuite.net/autosun/study/33280250-%5BJS%5D+Ajax+%E5%BB%BA%E7%AB%8B%E9%9D%9E%E5%90%8C%E6%AD%A5%E8%AB%8B%E6%B1%82%EF%BC%88%E4%B8%80%EF%BC%89","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript Arrow Functions","slug":"2019-12-27-JavaScript-22","date":"2019-12-28T16:00:00.000Z","updated":"2020-01-04T00:58:31.494Z","comments":true,"path":"2019/12/29/2019-12-27-JavaScript-22/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/12/29/2019-12-27-JavaScript-22/","excerpt":"","text":"箭頭函式運算式 (Arrow Function expression) 是在 ES6 新增的建立函式語法，這種寫法有著兩個重要的特性： 更簡短的函式寫法 this 變數強制綁定 箭頭函式（Arrow Function）傳統的函式寫法： 1234567891011//沒參數let myFunc = function()&#123; return 1;&#125;//有參數let fn = function(n1, n2)&#123; return n1+ n2;&#125;myFunc(); // 1fn(1,2); // 3 ES6 的箭頭函式寫法： 1234567//沒參數let myFunc = () =&gt; (1);//有參數let fn = (n1, n2) =&gt; (n1+n2);myFunc(); // 1fn(1,2); // 3 在使用箭頭函式中，如果函式沒有帶上參數記得加空括號 () ，有參數直接在 () 內填入參數即可。 如果函式最後要回傳值的話，可以省略 return 不寫。 當函式只有一個參數時，不需要使用括號從上面的例子可以發現，當函式無參數或有兩個以上的參數時，都要加上括號 ( )；當函數只有一個參數時，可以省略括號不寫。 123456//兩種寫法都可以//有加括號let fn = (n1) =&gt; (n1);//沒加括號let fn = n1 =&gt; n1;fn(1); // 1 我們使用括號 () 來定義函式帶入的參數，而大括號 {} 定義函式功能的一些 JavaScript 語句，如果函式有多行語句(表達式)時就要使用 {} ， {} 內需自行加入 return ，否則會出現 undefined ： 12345let fn = (n1) =&gt; &#123; n1 &#125;let myfunc = (n1) =&gt; &#123; return n1; &#125;fn(1); // undefinedmyfunc(1); // 1 匿名函式123456789101112131415161718192021222324252627282930//第一個範例//傳統的匿名函式const sum = function(a, b) &#123; return a+b;&#125;//匿名的箭頭函式const sum_arr = (x, y) =&gt; &#123; return x + y;&#125;;//第二個範例//傳統的匿名函式let fn = function()&#123; setTimeout(function()&#123; console.log(\"1秒\"); &#125;,100);&#125;//匿名的箭頭函式let fn_arr = function()&#123; setTimeout(() =&gt; &#123; console.log(\"1秒\"); &#125;,100);&#125;sum(1,2); // 3sum_arr(1,2); // 3fn(); // 1秒fn_arr(); // 1秒 指定參數的預設值1234567891011121314151617181920//傳統寫法function fn(name)&#123; if(name == undefined)&#123; name= \"Cyting\"; &#125; console.log(name);&#125;//ES6寫法function fn(name =\"Cyting\")&#123; console.log(name);&#125;//箭頭函式寫法let fn = (name=\"Cyting\") =&gt; &#123; console.log(name);&#125;fn(\"Cheng-Yi-Ting!\"); // Cheng-Yi-Ting!fn(); // Cyting 箭頭函式的 this不管是使用傳統的函式寫法或箭頭函式， this 都會存取到 window 物件（不清楚原因的話請先參考之前的文章 JavaScript THIS ）。 12345678910let fn = function()&#123; console.log(this);&#125;let fn2 = () =&gt; &#123; console.log(this);&#125;fn(); //[Window Object]fn2(); //[Window Object] func 和 setTimeout 箭頭函式的 this 均會指向 obj ： 1234567891011const obj = &#123; a:1 &#125;function func() &#123; console.log(this.a) // 1 setTimeout(() =&gt; &#123; console.log(this.a) // 1 &#125;, 1000)&#125;func.call(obj) 如果是傳統的函式寫法， setTimeout 的 this 會指向 window 物件： 12345678910const obj = &#123; a: 1 &#125;function func() &#123; console.log(this.a) // 1 setTimeout( function() &#123; console.log(this.a) // undefined &#125;, 1000)&#125;func.call(obj) 我們可以透過將 this 存在 that 變數中，之後就可以透過 that 存到之前 this 的參照： 12345678910const obj = &#123; a: 1 &#125;function func()&#123; const that = this setTimeout(function()&#123; console.log(that.a) // 1 &#125;, 1000)&#125;func.call(obj) 也可以透過 .bind() 來強制指定 this 為 () 內的物件，於是可以把 setTimeout 裡面的 this 指定為先前的 this ： 123456789const obj = &#123; a: 1 &#125;function func()&#123; setTimeout(function()&#123; console.log(this.a) // 1 &#125;.bind(this), 1000)&#125;func.call(obj) 傳統函式的 this 是根據呼叫方式的不同而有所不同；箭頭函式的 this 是綁定到其定義時所在的物件： 1234567891011121314151617181920212223var name = 'Cheng-Yi-Ting'var obj = &#123; name: 'Cyting', fun1: function () &#123; // 注意，這裡是 function，以此為基準產生一個作用域 console.log('1', this.name); // 1 'Cyting', setTimeout(() =&gt; &#123; console.log('2', this.name); // 2 'Cyting', console.log('3', this); // 3 obj 這個物件 &#125;, 1000); &#125;, fun2: () =&gt; &#123; // 注意，如果使用箭頭函式，this 依然指向 window console.log('4', this.name); // 4 'Cheng-Yi-Ting' setTimeout(() =&gt; &#123; console.log('5', this.name); // 5 'Cheng-Yi-Ting' console.log('6', this); // 6 window 物件 &#125;, 1000); &#125;&#125;obj.fun1();obj.fun2(); 一般函式是建立在 window 底下，所以箭頭函式自然會指向 window ；可以透過將箭頭函式宣告在物件內部，來將 this 指向該物件： 123456789101112131415var func = function () &#123; var func2 = function () &#123; setTimeout(() =&gt; &#123; console.log(this); &#125;, 1000); &#125;; var func3 = &#123; func: func2, value: 1 &#125; func2(); // this = window func3.func(); // func3 Object&#125;func(); func3() 是呼叫在物件內的函式，因此箭頭函式會是使用它所在的物件。 不可使用箭頭函式的情況apply, call, bind函式物件中的 call 、 apply 、 bind 這三個方法，無法覆蓋箭頭函式中的 this 值： 1234567891011121314let obj = &#123; value: 1&#125;const a = () =&gt; &#123; console.log(this);&#125;const b = function () &#123; console.log(this);&#125;a.call(obj); // 箭頭函式的情況，this 依然是 windowb.call(obj); // 一般函式 this 則是傳入的物件 建構函式箭頭函式無法像一般的函式一樣作為建構式使用，使用 new 語法會出現錯誤： 123456const Message = (text) =&gt; &#123; this.text = text&#125;const helloMessage = new Message('Hello World!');// \"TypeError: Message is not a constructor\" DOM事件處理函式在 HTML 中建立一個 button element，在 button 使用 addEventListener 事件監聽器： 123456789var button = document.querySelector('button');var fn_arr = () =&gt; &#123; console.log(this) // this 指 Window&#125;;var fn = function()&#123; console.log(this) // this 指 HTMLButtonElement&#125;button.addEventListener('click', fn_arr); 使用傳統的寫法，在觸發這個事件時所指稱的對象會從原本的 window 變成按鈕物件；若使用的是箭頭函式，則 this 一樣會是 window 物件。 Prototype 中定義的方法如果在原型中使用箭頭函式，此時箭頭函式內的 this 會指向 window ，若是在嚴格模式則會是 undefined ： 1234567891011121314151617181920function Person(firstName, lastName, age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age;&#125;Person.prototype.log1 = function () &#123; console.log(this.firstName+' '+this.lastName+ ', age:' + this.age);&#125;Person.prototype.log2 = () =&gt; &#123; console.log(this.firstName+' '+this.lastName+ ', age:' + this.age);&#125;const roman = new Person('Roman', 'Gonzalez', 18);roman.log1(); // Roman Gonzalez, age:18roman.log2(); // undefined undefined, age:undefined 結論箭頭函式語法 沒有參數時要有小括號。 只有一個參數時可以省略小括號。 若有兩個以上的參數要有小括號。 只有一行回傳值可以省略大括號。 箭頭函式限制 函式物件中的 call 、 apply 、 bind 這三個方法，無法覆蓋箭頭函式中的 this 值。 不可作為建構式使用，會在使用 new 時候拋出錯誤。 箭頭函式並沒有原型（prototype）屬性。 沒有一般函式有的隱藏 arguments 物件。 箭頭函式不能當作 generators 使用，使用 yield 會產生錯誤。 參考文獻 https://dotblogs.com.tw/shihgogo/2017/12/11/111122 https://ithelp.ithome.com.tw/articles/10185221 https://ithelp.ithome.com.tw/articles/10227798 https://pjchender.blogspot.com/2017/01/es6-arrow-function.html?m=1 https://wcc723.github.io/javascript/2017/12/21/javascript-es6-arrow-function/ https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/arrow_function.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript var , let , const","slug":"2019-12-21-JavaScript-21","date":"2019-12-24T16:00:00.000Z","updated":"2020-01-23T00:09:23.569Z","comments":true,"path":"2019/12/25/2019-12-21-JavaScript-21/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/12/25/2019-12-21-JavaScript-21/","excerpt":"","text":"在 ES6（ES2015） 之後宣告「變數」與「常數」，除了原本的 var 以外，還可以透過 let 與 const 做宣告，在本文中，我們會說明使用 var , let 和 const 的差異，並討論他們的作用域、變數初始化以及 hoisting 。 var 作用域123456789var Christmas = 'Merry Christmas and happy New Year!'function greeting () &#123; var hello = \"greeting\"; console.log(hello); // greeting&#125;greeting();console.log(hello); // error: hello is not defined 使用 var 宣告的變數是以函式作為作用域的分界，範例中的 Christmas 宣告在函式之外所以視為全域作用範圍（global），而 hello 宣告在函式之內所以其作用範圍於該函數之內。當我們執行 greeting() 可以存取到 hello ，而在 function 外就無法獲得該變數內容，所以在全域範圍中會找不到 hello 而產生 ReferenceError 的錯誤。 var 變數可以重複宣告JavaScript 允許重複宣告變數，不過實際上並不會進行重覆宣告，只會將其視為指派資料值： 12345var Christmas = 'Merry Christmas and happy New Year!'var Christmas;console.log(Christmas); // 'Merry Christmas and happy New Year!'var Christmas = 'We wish you a merry Christmas.'console.log(Christmas); // 'We wish you a merry Christmas.' var 的問題var 是以函式為變數作用域的分界，在一些使用了區塊語句： if , else , for , while 等等區塊語句中，使用 var 宣告的變數會曝露到全域作用範圍： 12345678910function greeting () &#123; var hello = \"greeting\";&#125;if(true)&#123; var say = \"Christmas time\";&#125;console.log(hello) // hello is not definedconsole.log(say) // 可存取 使用 var 宣告變數容易造成程式上的誤解： 12345678var hello = \"greeting\";var counts = 2;if(counts &gt; 1)&#123; var hello = \"Christmas time\";&#125;console.log(hello) // Christmas time 因為 counts &gt; 1 成立，所以 hello 會被重新賦予新值，如果在其他程式碼也有使用到 hello 這個變數，可能會不小心就更動了變數的內容造成程式執行錯誤。 透過 ES6 加入的 let 或 const 來宣告，以區塊語句為分界的作用域，將會更明確且不易發生錯誤。 使用 let 宣告 hello 和 say ，本來在全域範圍中可以存取到的 say 變成 ReferenceError ，因為 let 和 const 是用大括號 {} 來區分作用域： 12345678910function greeting () &#123; let hello = \"greeting\";&#125;if(true)&#123; const say = \"Christmas time\";&#125;console.log(hello) // hello is not definedconsole.log(say ) // say is not defined 下面例子中的 hello 也只能在 {} 內進行存取： 12345678let counts = 2;if(counts &gt; 1)&#123; let hello = \"Christmas time\"; console.log(hello);// \"Christmas time\";&#125;console.log(hello) // hello is not defined let 不能重複宣告使用 let 宣告的變數不能再其作用域中重複宣告，但可以更新其值： 12let hello = \"greeting\";hello = 'Merry Christmas and happy New Year!'; 以下例子會輸出 error：Identifier ‘hello’ has already been declared： 12let hello = \"greeting\";let hello = 'Merry Christmas and happy New Year!'; 如果同名的變數在不同的作用域就不會出錯： 12345678let hello = \"greeting\";if (true) &#123; let hello = 'Merry Christmas and happy New Year!'; console.log(hello);//\"Merry Christmas and happy New Year!\"&#125;console.log(hello);// \"greeting\" var 使用同名變數不會產生錯誤訊息，而使用 let 宣告的變數只能在同一個作用域中宣告一次，這種做法將可避免更多錯誤的產生。 HoistingJavaScript 會將變數宣告放到該 Scope 的最上層，並將該變數的初始值設為 undefined ，這種特性稱為「變數提升」 (Variables Hoisting)： 12console.log (Christmas); // undefinedvar Christmas = 'Merry Christmas and happy New Year!' 上面程式碼等同於下面： 123var Christmas;console.log(Christmas); // undefinedChristmas = 'Merry Christmas and happy New Year!' 由於 JavaScript 的 Hoisting 特性，建議將變數宣告都放在 Scope 的最上方，養成先宣告完成後再使用的習慣，讓程式邏輯更清楚，也可以避免預期外的結果或錯誤發生。 Temporal dead zone（TDZ）TDZ 為 ES6 的新用語，它的作用主要是用在 let 和 const 上； var 用 undefined 來初始化，代表在宣告之前存取變數會得到 undefined 。 let 和 const 一樣會有 Hoisting，而 let 不會初始化變數的值，如果再宣告前存取會出現 ReferenceError ： 12console.log (Christmas); // ReferenceError: Christmas is not definedlet Christmas = 'Merry Christmas and happy New Year!' TDZ 表示一個尚未被初始化的狀態，有一個變數經過宣告後但未被初始化，此時存取它就會產生 ReferenceError 。下面例子中的變數 Christmas 會先被提升到函式的最上面；此時會產生 TDZ，如果程式流程未執行到 Christmas 的宣告語句時，就算是在 TDZ 作用的期間，此時存取 Christmas 就會出現 ReferenceError 錯誤。 1234567let Christmas = 'Merry Christmas and happy New Year!';(function() &#123; // 產生 TDZ console.log(Christmas) // TDZ期間存取，Cannot access 'Christmas' before initialization let Christmas = 'We wish you a merry Christmas.' // 對 Christmas 的宣告語句，這裡結束 TDZ&#125;)(); 如果先初始化值，再存取就不會出錯： 12345let Christmas = 'Merry Christmas and happy New Year!';(function() &#123; console.log(Christmas) // 'Merry Christmas and happy New Year!'&#125;()); CONSTlet 和 const 一樣是區塊作用域，唯一的差別是使用 const 宣告的變數代表常數 ，宣告的同時就要指定給值，並且不能重新賦予新值。 1234let hello = \"greeting\";const say = \"Christmas time\";hello = 'Christmas Eve'say = 'Santa Claus' // TypeError: Assignment to constant variable. 重新給值就會出錯： 12const say = \"Christmas\";const say = \"Christmas time\"; // Identifier 'say' has already been declared const 宣告的常數代表它是唯讀的，但並非代表這個參照到的值是不可改變的(immutable)。如果宣告的常數是一個參照類型的值，像是「物件」或是「陣列」，那裡面的值是可以改變的： 1234567const person = &#123; name : 'Cheng Yi-Ting'&#125;const test = []person.name = 'CyTing' test[0] = '1' 如果只改變物件屬性的屬性值並不會出錯，但無法對整個物件分配新值： 12345const person = &#123; name : 'Cheng Yi-Ting'&#125;person = &#123;&#125; // Assignment to constant variable. for 迴圈中的 let假設想要透過迴圈依序印出數字 0 到 4 ，並搭配 setTimeout 來達成每秒鐘輸出一個數字；過去我們可以透過在 for 迴圈中加入 IIFE 來完成，每次將當下的 i 作為參數傳入函式： 1234567for( var i = 0; i &lt; 5; i++ ) &#123; (function(x)&#123; window.setTimeout(function() &#123; console.log(x); &#125;, 1000 * x); &#125;)(i);&#125; 在 ES6 以後可以透過 let 來簡化，因為使用 {} 來區分作用域，所以每次 for 迴圈執行時，用 let 宣告的變數都會重新綁定一次，所以可以保留當下執行 i 的值： 12345for( let i = 0; i &lt; 5; i++ ) &#123; window.setTimeout(function() &#123; console.log(i); &#125;, 1000 * i);&#125; 參考文獻 https://dev.to/sarah_chima/var-let-and-const–whats-the-difference-69e https://tylermcginnis.com/var-let-const/ https://eddychang.me/es6-tdz/ https://ithelp.ithome.com.tw/articles/10225604 https://ithelp.ithome.com.tw/articles/10185142","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://cheng-yi-ting.github.io/tags/ES6/"}]},{"title":"JavaScript ES6 Class","slug":"2019-12-13-JavaScript-20","date":"2019-12-13T16:00:00.000Z","updated":"2019-12-21T13:14:24.494Z","comments":true,"path":"2019/12/14/2019-12-13-JavaScript-20/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/12/14/2019-12-13-JavaScript-20/","excerpt":"","text":"JavaScript是一個以原型為基礎(prototype-based)的物件導向程式語言，而 ES6 Class 只是個語法糖(syntactical sugar)，目的是提供更簡潔的語法來作物件建立與繼承。 我們過去使用 function constructor 來產生類別物件： 12345678910111213141516171819202122function Employee(name, age,salary) &#123; // 定義基本屬性 this.name = name; this.age = age; this.salary = salary;&#125;// 原型方法Employee.prototype.getName = function() &#123; return this.name;&#125;Employee.prototype.employeeDetails = function() &#123; return 'Name: '+this.name+', Age:'+this.age+', salary:'+this.salary;&#125;var felix = new Employee('Felix', 18, 22000);//Name: Felix, Age:18, salary:22000console.log(felix.employeeDetails());var hector= new Employee('Hector', 25, 36000);//Name: Hector, Age:25, salary:36000console.log(hector.employeeDetails()); ES6 Constructor類別宣告（Class Declaration）一個定義類別的方法是使用類別宣告(class declaration)，使用關鍵字 class 搭配類別名稱(此例為 “Employee”)。 1234567class Employee&#123; constructor(name, age, salary) &#123; this.name= name; this.age = age; this.salary= salary; &#125;&#125; 類別敘述（Class Expression）類別敘述是定義類別的另一種方法，可區分為有名稱或無名稱的類別敘述。 12345678910111213141516171819// named class expressionvar Employee = class &#123; constructor(name, age, salary) &#123; this.name= name; this.age = age; this.salary= salary; &#125;&#125;// unnamed class expressionvar Employee = class Employee&#123; constructor(name, age, salary) &#123; this.name= name; this.age = age; this.salary= salary; &#125;&#125;var hector= new Employee('Hector', 25, 36000); Hoisting函式宣告和類別宣告的一個重要差別在於函式宣告是會 hoisted，而類別宣告則不會。使用類別宣告方法，需要先宣告類別才能進行存取，否則會出現 ReferenceError 的錯誤。 1234//Uncaught ReferenceError: Cannot access 'Employee' before initializationvar Vincent = new Employee(); class Employee&#123;&#125; 以下為將第一個例子修改為 Class 方法： 12345678910111213141516171819202122232425class Employee&#123; constructor(name, age, salary) &#123; // 定義基本屬性 this.name= name; this.age = age; this.salary= salary; &#125; // 原型方法 getName() &#123; return this.name; &#125; employeeDetails() &#123; return 'Name: '+this.name+', Age:'+this.age+', salary:'+this.salary; &#125;&#125;//Name: Felix, Age:18, salary:22000var felix = new Employee('Felix', 18, 22000);console.log(felix.employeeDetails());//Name: Hector, Age:25, salary:36000var hector= new Employee('Hector', 25, 36000);console.log(hector.employeeDetails()); 改由 constructor 定義物件內的屬性，並將以前的 prototype 直接寫在 class 內，讓程式碼更為直觀。 靜態方法我們可以在 class 內定義靜態方法，靜態方法只能被原型使用，無法在創立的物件上使用。 123456789101112131415161718class Employee&#123; constructor(name, age, salary) &#123; this.name= name; this.age = age; this.salary= salary; &#125; static testMethod()&#123; return 'static method has been called.'; &#125;&#125; var hector= new Employee('Hector', 25, 36000);//hector.testMethod is not a functionhector.testMethod();// 'static method has been called.'Employee.testMethod() Get and Setget 與 set 關鍵字分別代表取得方法和設定方法，一般的公開的的屬性不需要用到這兩種方法，本來就能直接取值或設定；只有私有屬性才需要用到 get 和 set 方法來作取得或設定。 1234567891011121314151617181920212223242526272829// ES6 get and setclass Employee&#123; constructor(name, age) &#123; this.name= name; this.age = age; &#125; get salary() &#123; console.log(\"The code executed on getting obj.salary\"); if (this._salary!== undefined) &#123; return this._salary; &#125; else &#123; return 'no salary prop' &#125; &#125; set salary(value) &#123; console.log(\"The code executed on setting obj.salary = value;\") this._salary=value; &#125;&#125;var hector = new Employee('Hector',18);//The code executed on setting obj.salary = value;hector.salary='35000';//The code executed on getting obj.salary//\"35000\"hector.salary; getter不會有傳入參數，setter 則只能傳入一個參數。 繼承我們之前透過函式建構式來達成類別繼承，為了讓子類別繼承父類別建構函式的內容，所以我們必須在子類別建構函式中呼叫父類別建構函式： 123456789101112// Person 的 constructor functionfunction Person(name,age) &#123; this.name = name || 'default'; this.age = age || 0; this.skill= ['HTML','CSS'];&#125;// Student 的 constructor functionfunction Student(name) &#123; this.name = name; this.score = 100; Person.call(this,name);&#125; extendsES6 簡化類別宣告的過程，我們不需要再去修改原型物件，也能直接完成繼承的效果。 這裡會使用到兩個關鍵字： extends: 繼承於另一個原型之下。 super : 使用上層的值(屬性)。 創造子類別 Student，並使用 extends 指向 Person，讓 Student 繼承 Person： 12345678910111213141516171819202122232425class Person&#123; constructor(name, age) &#123; this.name = name || 'default'; this.age = age || 0; this.skill= ['HTML','CSS']; &#125; hi() &#123; console.log(`Hi, $&#123;this.name&#125; ,My age is $&#123;this.age&#125;.`); &#125;&#125;class Student extends Person&#123; constructor(name) &#123; super(name); this.name = name; this.score = 100; &#125; say() &#123; console.log(`Say, $&#123;this.name&#125; ,My score is $&#123;this.score&#125;.`); &#125;&#125;var roman = new Student('roman'); 繼承的子類別中的建構式， super() 需要放在建構式第一行，這是標準的呼叫方式。如果有需要傳入參數可以傳入。 繼承的子類別中的屬性與方法，都會覆蓋掉原有的在父母類別中的同名稱屬性或方法，要區分不同的屬性或方法要用 super 關鍵字來存取父母類別中的屬性或方法。 1234567891011121314151617181920212223242526class Person&#123; constructor(name, age) &#123; this.name = name || 'default'; this.age = age || 0; this.skill= ['HTML','CSS']; &#125; hi() &#123; console.log(`Hi, $&#123;this.name&#125; ,My age is $&#123;this.age&#125;.`); &#125;&#125;class Student extends Person&#123; constructor(name) &#123; super(name); this.name = name; this.score = 100; &#125; hi() &#123; console.log(super.hi()); &#125;&#125;var roman = new Student('roman');// Hi, roman ,My age is 0.roman.hi(); 參考文獻 https://ithelp.ithome.com.tw/articles/10185583 https://ithelp.ithome.com.tw/articles/10195056 https://ithelp.ithome.com.tw/articles/10226111 https://ithelp.ithome.com.tw/articles/10196867","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript Object-oriented programming","slug":"2019-12-12-JavaScript-19","date":"2019-12-12T16:00:00.000Z","updated":"2020-01-10T15:33:03.842Z","comments":true,"path":"2019/12/13/2019-12-12-JavaScript-19/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/12/13/2019-12-12-JavaScript-19/","excerpt":"","text":"Prototype-based Inheritance (基於原型的繼承)JavaScript 的繼承是 prototype-based，意思就是在 JavaScript 中沒有 class，所有的 object 都繼承自其它的 object。 以下為繼承的實作範例，先建立父層類別 Person 和子層類別 Student： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Person 的 constructor functionfunction Person(name,age) &#123; this.name = name || 'default'; this.age = age || 0; this.skill= ['HTML','CSS'];&#125;// Person 的 prototypePerson.prototype.hi= function () &#123; console.log(`Hi, $&#123;this.name&#125; ,My age is $&#123;this.age&#125;.`);&#125;// Student 的 constructor functionfunction Student(name) &#123; this.name = name; this.score = 100;&#125;// Student 繼承 PersonStudent.prototype = new Person()// Student的 prototype 方法Student.prototype.say = function() &#123; console.log(`Say, $&#123;this.name&#125; ,My score is $&#123;this.score&#125;.`);&#125;;// 建立物件實例var roman = new Student('roman');var hera = new Student('hera');// Hi, roman ,My age is 0.roman.hi();// Say, roman ,My score is 100.roman.say();roman.skill.push('JavaScript')console.log(roman.skill) // [\"HTML\",\"CSS\",\"JavaScript\"]console.log(hera.skill) // [\"HTML\",\"CSS\",\"JavaScript\"]//物件的繼承關係 (prototype chain) console.log(roman.__proto__ === Student.prototype)//trueconsole.log(Student.prototype.__proto__ === Person.prototype)//true 由於 skill 這個屬性是定義在父層元素，而父層元素是會被子層元素所影響；因為 roman 物件中並沒有 skill 屬性，因此會透過原型練存取到 Person 的 skill(roman.__proto__.skill)，造成修改 roman.skill 卻連帶的影響到 hera.skill 。 123roman.skill.push('JavaScript')console.log(roman.skill) // [\"HTML\",\"CSS\",\"JavaScript\"]console.log(hera.skill) // [\"HTML\",\"CSS\",\"JavaScript\"] 物件實例不會影響到父層屬性為了避免子類別實例影響父類別屬性的問題，我們可以使用 Person.call(this) ，把 Person 裡面的 this 指稱對象改成當前透過 Student 建構式所建立的物件實例： 12345function Student(name) &#123; this.name = name; this.score = 100; Person.call(this,name); &#125; 等同於把原本 Person 的內容複製到 Student 中： 12345678function Student(name) &#123; //父層屬性 this.name = name || 'default'; this.age = age || 0; this.skill= ['HTML','CSS']; //子層屬性 this.score = 100;&#125; 這時候物件實例就不會共享到父層的屬性了： 1234567// 建立物件實例var roman = new Student('roman');var hera = new Student('hera');roman.skill.push('JavaScript')console.log(roman.skill) // [\"HTML\",\"CSS\",\"JavaScript\"]console.log(hera.skill) // [\"HTML\",\"CSS\"] Object.create() and new operator 差異也可以使用此方法來實現繼承： 1Student.prototype = Object.create(Person.prototype); 為了避免瀏覽器太舊不支援 Object.create() ，可自行 polyfill 來達成一樣的效果： 123456789101112// 同 Student.prototype = Object.create(Person.prototype)Student.prototype = inherit(Person.prototype);// Object.create()function inherit(proto) &#123; //先建立一個空的 F constructor function function F() &#123;&#125;; //將 F.prototype 指向傳進來的 proto F.prototype = proto; //用函式建構式的方式回傳 return new F();&#125; 兩種方法差異在於 new Person() 會執行建構式中的程式碼，而 object.create() 並不會，以下為第一個範例的修改： 12345678910111213141516171819202122232425262728293031323334353637// Person 的 constructor functionfunction Person(name,age) &#123; this.name = name || 'default'; this.age = age || 0; this.skill= ['HTML','CSS'];&#125;// Person 的 prototypePerson.prototype.hi= function () &#123; console.log(`Hi, $&#123;this.name&#125; ,My age is $&#123;this.age&#125;.`);&#125;// Student 的 constructor functionfunction Student(name) &#123; this.name = name; this.score = 100;&#125;// Student 繼承 PersonStudent.prototype = Object.create(Person.prototype)// Student的 prototype 方法Student.prototype.say = function() &#123; console.log(`Say, $&#123;this.name&#125; ,My score is $&#123;this.score&#125;.`);&#125;;// 建立物件實例var roman = new Student('roman');var hera = new Student('hera');// Hi, roman ,My age is undefined.roman.hi();// Say, roman ,My score is 100.roman.say();//Uncaught TypeError: Cannot read property 'push' of undefinedroman.skill.push('JavaScript') 因為沒有執行 Person 函式建構式的內容，當呼叫 roman.hi(); 中的 this.age 為 undefined；沒有 skill 屬性所以也無法使用 push 方法。 以下為使用兩種方式建立 roman 物件： Student.prototype = new Person() Student.prototype = Object.create(Person.prototype) Polymorphism (多型)透過在子類別中重寫覆蓋 (override) 掉父類別中的方法或屬性來完成多型。 123Student.prototype.hi = function() &#123; console.log(`Hi, $&#123;this.name&#125; ,My score is $&#123;this.score&#125;.`);&#125;; 因為原型鏈的關係，當執行 roman.hi() 時，就會優先執行 Student 中定義的 hi。 Encapsulation (封裝)無法直接存取底線開頭 (underscore) 的屬性或方法，藉由公開的 hi() 來呼叫 __hi() 。 123456789101112131415161718192021function Person(name,age) &#123; this.name = name || 'default'; this.age = age || 0; this.skill= ['HTML','CSS'];&#125;// protectedPerson.prototype.__hi= function () &#123; console.log(`Hi, $&#123;this.name&#125; ,My age is $&#123;this.age&#125;.`);&#125;// publicPerson.prototype.hi= function () &#123; this.__hi();&#125;var roman = new Person('roman','18');// Hi, roman ,My age is 18.roman.hi(); 靜態屬性或方法在 JavaScript 中的實作方式，是直接將方法或屬性加在 constructor function 上。 123456789101112131415161718function Person(name,age) &#123; Person.count++;&#125;// 靜態屬性Person.count = 0;// 靜態方法Person.getCount = function() &#123; console.log(`$&#123;Person.count&#125;.`);&#125;;new Person();new Person();// 顯示 2Person.getCount(); 參考文獻 https://www.fooish.com/javascript/oop-object-oriented-programming.html https://ithelp.ithome.com.tw/articles/10196763 https://pjchender.github.io/2018/08/01/js-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-javascript-object-oriented-javascript/ https://github.com/noahlam/articles/blob/master/JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF(%E4%B8%8A).md","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 原型鏈（Prototype Chain）","slug":"2019-11-19-JavaScript-18","date":"2019-12-11T16:00:00.000Z","updated":"2020-01-28T04:20:22.344Z","comments":true,"path":"2019/12/12/2019-11-19-JavaScript-18/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/12/12/2019-11-19-JavaScript-18/","excerpt":"","text":"前言物件導向程式設計（OOP）的基本概念是使用物件的方式來表示，透過類別（class）的函式建構式（function constructor）可以產生物件實例（object instance）。 JavaScript 並非真正的物件導向 (OO) 語言，它是一個以原型為基礎 (Prototype-based) 的語言。因為沒有 Class，而是透過 「原型」(prototype) 來實現繼承實作。 建構式在 JavaScript 中，一個 Function 是不是建構式並不是取決於它的宣告方式，而是取決於它是不是用 new 來執行的。如果是用 new 執行一個 Function 時，我們就稱做這種呼叫為 建構式呼叫。當我們用建構式呼叫去執行一個 Function，這個 Function 就會被當作建構式。 使用 new 建構式呼叫的時候，實際上會有幾件事會被執行： 首先會新建出一個物件。 將物件的 .__proto__ 指向建構子的 prototype ，形成原型串鏈。 將建構子的 this 指向 new 出來的新物件。 回傳新建物件 ( 如果建構式本身沒有回傳東西的話 )。 先來看一下 function constructor 的實際應用，透過 function 的方式來建立一個新的物件，如果我們想要建立出同屬性名稱但不同屬性值的物件內容，我們可以把物件的屬性值變成參數，如此就能透過此 function constructor 建立出許多不同的物件： 12345678910111213141516function Person(firstName, lastName, age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.log = function () &#123; console.log(this.firstName+' '+this.lastName+ ', age:' + this.age); &#125;&#125;;var roman = new Person('Roman','Gonzalez', 18);roman.log(); // Roman Gonzalez, age:18var bobby = new Person('Bobby','Lashley', 20);bobby.log(); // Bobby Lashley, age:20console.log(roman.log === bobby.log) // false name 跟 age 這兩個屬性在每一個 instance 都不一定會相同，而 log 這個 method 其實都在做同一件事情，而且還佔用了兩份空間。意思就是他們其實是兩個不同的 function 。 因為每一個 instance 彼此之間是可以共享方法的，所以我們可以透過把 log 這個 function 抽出來，指定在 Person.prototype 上面，這樣所有用 Person 建構出來的 instance 都可以共享這個方法，將可以有效減少記憶體占用的問題。 1234567891011121314function Person(firstName, lastName, age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age;&#125;;Person.prototype.log = function () &#123; console.log(this.firstName+' '+this.lastName+ ', age:' + this.age);&#125;var roman = new Person('Roman','Gonzalez', 18);var bobby = new Person('Bobby','Lashley', 20);console.log(roman.log === bobby.log) // true 共用的屬性或方法，不用每次都幫實體建立一份，提出來放到 prototype 即可。 以下是嘗試存取屬性時會發生的事： 12345678910111213141516171819202122232425262728// 利用含有 a 與 b 屬性的 f 函式，建立一個 o 物件：let f = function () &#123; this.a = 1; this.b = 2;&#125;let o = new f(); // &#123;a: 1, b: 2&#125;// 接著針對 f 函式的原型添加屬性f.prototype.b = 3;f.prototype.c = 4;console.log(o.a); // 1// o 有屬性「a」嗎？有，該數值為 1。console.log(o.b); // 2// o 有屬性「b」嗎？有，該數值為 2。// o 還有個原型屬性「b」，但這裡沒有被訪問到。// 這稱作「property shadowing」。console.log(o.c); // 4// o 有屬性「c」嗎？沒有，那就找 o 的原型看看。// o 在「o.[[Prototype]]」有屬性「c」嗎？有，該數值為 4。console.log(o.d); // undefined// o 有屬性「d」嗎？沒有，那就找 o 的原型看看。// o 在「o.[[Prototype]]」有屬性「d」嗎？沒有，那就找 o.[[Prototype]] 的原型看看。// o 在「o.[[Prototype]].[[Prototype]]」是 null，停止搜尋。// 找不到任何屬性，回傳 undefined。 增加原生原型的屬性和方法上面都是設定自己建立的物件原型，也能修改預設的原生原型，但不要不小心把原本內建的屬性或方法給無意間覆蓋掉。 例如在 Array.prototype 上面加上函式： 123456789101112131415161718192021Array.prototype.push(\"Cyting\")var myname = [];myname[0]; //\"Cyting\"var ting = [];ting[0]; //\"Cyting\"Array.prototype.top = function () &#123; return this[0];&#125;;myname.top(); //\"Cyting\"ting.top(); //\"Cyting\"String.prototype.isLengthGreaterThan = function(limit)&#123; return this.length &gt; limit;&#125;console.log(\"Cyting\".isLengthGreaterThan(4)); // True 在 Array.prototype 中 push 一段字串進去，接著新增 top 函式回傳字串內容；只要宣告出陣列型別的資料型態，都會有該字串內容，也都能呼叫 top 函式。 修改 Prototype 方法我們可以修改某個 function constructor 的 prototype 內容，當改變了該函式建構式中 prototype 內的方法，那麼所有根據這個建構式所建立的實例（不管是修改 prototype 之前或之後所建立的實例），都會套用更新後的方法： 12345678910111213141516171819202122function Person(firstName, lastName, age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age;&#125;;Person.prototype.log = function () &#123; console.log(`Hi $&#123;this.firstName&#125; $&#123;this.lastName&#125;`); &#125;var roman = new Person('Roman','Gonzalez', 18);roman.log(); // Hi Roman Gonzalezvar bobby = new Person('Bobby','Lashley', 20);bobby.log(); // Hi Bobby Lashley// 修改原本的 log 方法Person.prototype.log= function() &#123; console.log(`Hello, $&#123;this.firstName&#125; $&#123;this.lastName&#125;`);&#125;roman.log(); // Hello, Roman Gonzalezbobby.log(); // Hello, Bobby Lashley 原型鏈 Prototype Chain當物件試圖存取一個物件的屬性時，其不僅會尋找該物件，也會尋找該物件的原型、原型的原型……直到找到相符合的屬性，或是到達原型鏈的尾端。 所有的物件裡面都會包含原型（prototype）這個物件，在 JavaScript 中這個物件的名稱為 __proto__ 。如果在原本的物件中找不到指定的屬性名稱或方法時，就會進一步到 __proto__ 裡面來找。 以上面 var roman = new Person(‘Roman’,’Gonzalez’, 18); 為例，當呼叫 roman.log() 方法，因為 roman 這個 instance 本身並沒有 log 這個 function，而 roman 是 Person 的 instance，所以如果在 roman 本身找不到，就會嘗試從 Person.prototype 去找。 我們想要取得某個物件的原型物件時，就可以透過以下兩個方式： 12345//可以使用 .__proto__ 來取得 [[Prototype]] roman.__proto__ === Person.prototype // true//也可以用 Object.getPrototypeOf(..)來取得 [[Prototype]]Object.getPrototypeOf(roman) === Person.prototype // true roman 的 __proto__ 會指向 Person.prototype ，當發現 roman 沒有 log 這個 method 的時候，JavaScript 就會試著透過 __proto__ 找到 Person.prototype ，去看 Person.prototype 裡面有沒有 log 這個 method。 假如 Person.prototype 還是沒有呢？那就繼續依照這個規則，去看 Person.prototype.__proto__ 裡面有沒有 log 這個 method，就這樣一直不斷找下去。直到該物件的 __proto__ 為 null 為止，意思就是找到最上層了。 而上面這一條透過 __proto__ 不斷串起來的鍊，就稱為原型鍊。透過這一條原型鍊來呼叫自己 parent 的 method，讓 JavaScript 達到類似其他物件導向語言般的類別、繼承功能。 12345678// roman.__proto__ 會指向 Person.prototypeconsole.log(roman.__proto__ === Person.prototype) // true// Person.prototype.__proto__ 會指向 Object.prototypeconsole.log(Person.prototype.__proto__ === Object.prototype) // true// Object.prototype.__proto__ 會指向 null，這就是原型鍊的頂端了console.log(Object.prototype.__proto__) // null hasOwnProperty如果想知道一個屬性是存在 instance 身上，還是存在於它屬於的原型鍊當中，可以用 hasOwnProperty 這個方法： 123var roman = new Person('Roman','Gonzalez', 18);console.log(roman.hasOwnProperty('log')); // falseconsole.log(roman.__proto__.hasOwnProperty('log')); // true hasOwnProperty 只會檢查該物件，而不會檢查整條原型串鏈；可以透過迴圈來列出整個原型鏈且為可列舉的屬性；prop 是自訂的變數，會把該物件的屬性存在這個變數中，接著讀取下一個屬性，重覆直到沒有屬性為止，透過 for…in 把該物件中的所有屬性名稱和屬性值都列出來，列出的項目也包含被添加過的屬性或方法： 1234567for (var prop in roman) &#123; console.log(prop);&#125;//firstName//lastName//age//log instanceof檢查物件是否為指定的建構子所建立的實體，位於 instanceof 左邊的運算元是物件，右邊的是函式，若左邊的物件是由右邊函式所產生的，則會回傳 true，否則為 false。 123roman instanceof Person // trueroman instanceof Object // trueroman instanceof Array // false A instanceof B 就是拿來判斷 A 是不是 B 的 instance 只要能在 A 的原型鍊裡面找到 B 的 prototype，就會回傳 true。 isPrototypeOf與 instanceof 不同之處只在於運算元的資料型別不同而已，但功能是相同的。 123Person.prototype.isPrototypeOf(roman) // trueObject.prototype.isPrototypeOf(roman) // trueArray.prototype.isPrototypeOf(roman) // false 如果 A.isPrototypeOf(B) 返回 true 則 B instanceof A 一定返回 true 。 Object.prototype當我們嘗試在某個物件存取一個不存在該物件的屬性時，它會繼續往它的「原型物件」[[prototype]] 去尋找，直到找到 Object.prototype 才停止。 1234567891011121314// 這兩個互為彼此的 instanceconsole.log(Function instanceof Object); // trueconsole.log(Object instanceof Function); // true// Function 的 __proto__ 會指向 Function.prototype// Function.prototype 的 __proto__ 會指向 Object.prototypeconsole.log(Function.__proto__ === Function.prototype); // trueconsole.log(Function.__proto__.__proto__ === Object.prototype); //true// Object 的 __proto__ 會指向 Function.prototypeconsole.log(Object.__proto__ === Function.prototype); // trueconsole.log(Person.__proto__ === Function.prototype); // trueconsole.log(Function.prototype.__proto__ === Object.prototype) // trueconsole.log(Object.prototype.__proto__); //null constructor每一個 prototype 都會有一個有 constructor 屬性，而這個屬性會指向構造函數，例如 Person.prototype 的構造函數就是Person。 12345678910111213141516171819function Person(firstName, lastName, age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age;&#125;;Person.prototype.log = function () &#123; console.log(`Hi $&#123;this.firstName&#125; $&#123;this.lastName&#125;`); &#125;var roman = new Person('Roman','Gonzalez', 18);// 往原型鍊去找console.log(roman.constructor === Person); // trueconsole.log(roman.hasOwnProperty('constructor')); // false// Person 的 constructor 就是 Personconsole.log(Person.prototype.constructor === Person); // trueconsole.log(Person.prototype.hasOwnProperty('constructor')); // true X.prototype.constructor === X ，將 X 用 Function, Person, Object 帶進去都會是 true。 Object.create() and new operator 差異以下為使用 Object.create 方式： 12345678910var dog = &#123; eat: function() &#123; console.log(this.eatFood) &#125;&#125;;var maddie = Object.create(dog);console.log(dog.isPrototypeOf(maddie)); //truemaddie.eatFood = 'NomNomNom'; maddie.eat(); //NomNomNom 執行流程如下： 建立一個 dog 物件。 使用 Object.create(dog) 將 將 maddie 的 [[Prototype]] 指向 dog 。 檢查 maddie 的 prototype 是不是 dog，回傳 true 。 設定 maddie 的 eatFood 屬性值。 呼叫 eat function。 Javascript 透過 prototype chain 找到 eat method 。 以下為使用 new operator 方式： 12345678910var Dog = function()&#123; this.eatFood = 'NomNomNom'; this.eat = function()&#123; console.log(this.eatFood) &#125;&#125;;var maddie = new(Dog);console.log(maddie instanceof Dog); // Truemaddie.eat(); //NomNomNom 執行流程如下： 建立一個 maddie 物件。 透過 function constructor 將 maddie 的 [[Prototype]] 指向 Dog 的 Prototype。 設定建構式中的 this 到物件。 回傳所建立的物件。 檢查 maddie 是不是 Dog 的 instance ，回傳 true 。 呼叫 eat function。 Javascript 透過 prototype chain 找到 eat method 。 再看一個例子： 123456789101112131415function Dog()&#123; this.pupper = 'Pupper';&#125;;Dog.prototype.pupperino = 'Pups.';var maddie = new Dog();var buddy = Object.create(Dog.prototype);//Using Object.create()console.log(buddy.pupper); //Output is undefinedconsole.log(buddy.pupperino); //Output is Pups.//Using New Keywordconsole.log(maddie.pupper); //Output is Pupperconsole.log(maddie.pupperino); //Output is Pups. 1console.log(buddy.pupper); //Output is undefined 大家有注意到 buddy.pupper 是 undefined 嗎？即使 Object.create() 將 prototype 指定為 Dog ，但是 buddy 並沒有存取到建構式中的 this.pupper ，兩者之間的主要差別就是 new Dog 會執行建構式中的程式碼，而 object.create 並不會執行建構式裡面的內容。 以下為另一個範例： 123456789101112131415161718192021function Test()&#123; this.prop1 = 'prop1'; this.prop2 = 'prop2'; this.func1 = function()&#123; return this.prop1 + this.prop2; &#125;&#125;;Test.prototype.protoProp1 = 'protoProp1';Test.prototype.protoProp2 = 'protoProp2';var newKeywordTest = new Test();var objectCreateTest = Object.create(Test.prototype);/* Object.create */console.log(objectCreateTest.prop1); // undefinedconsole.log(objectCreateTest.protoProp1); // protoProp1 console.log(objectCreateTest.__proto__.protoProp1); // protoProp1/* new */console.log(newKeywordTest.prop1); // prop1console.log(newKeywordTest.__proto__.protoProp1); // protoProp1 此範例比較三個不同的建立方式： 1234567891011121314function Test()&#123; this.prop1 = 'prop1'; this.prop2 = 'prop2'; this.func1 = function()&#123; return this.prop1 + this.prop2; &#125;&#125;;Test.prototype.protoProp1 = 'protoProp1';Test.prototype.protoProp2 = 'protoProp2';var a = new Test();var b = Object.create(Test.prototype);var c = Object.create(Test); 讓我們來看一下 a ,b ,c 三個物件內容在 console 輸出的結果： 結論所謂的 Prototype 就是原型，所有函式上面都有預設有一個公開的 Prototype 屬性，而被此建構式新建出來的物件都可以透過 [[Prototype]] 參考連結到這個原型物件上來存取其上的屬性，也就能建立出 類似物件導向概念 的程式。 整理一下本篇中出現的名詞： Prototype： 也就是原型物件。 所有函式上面都有預設有一個公開的 Prototype 屬性(原型物件)。被函式建立出的物件都可以存取其對應的原型物件。 [[Prototype]]： 用來讓物件能夠連結到其原型物件上的一個參考。 這是一個不允許外部存取的屬性。 __proto__： 相當於可存取的 [[Prototype]]，為了方便存取 Prototype 而生。 雖已於 ES6 中列為標準，但為了效能考量還是不建議使用。 參考文獻 https://blog.techbridge.cc/2017/04/22/javascript-prototype/ https://cythilya.github.io/2018/10/26/prototype/ https://ithelp.ithome.com.tw/articles/10194356 https://ithelp.ithome.com.tw/articles/10196639 https://pjchender.github.io/2018/08/01/js-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-javascript-object-oriented-javascript/ https://medium.com/@jonathanvox01/understanding-the-difference-between-object-create-and-the-new-operator-b2a2f4749358 https://stackoverflow.com/questions/4166616/understanding-the-difference-between-object-create-and-new-somefunction","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript Copy","slug":"2019-11-17-JavaScript-16","date":"2019-11-18T16:00:00.000Z","updated":"2019-11-19T08:16:03.354Z","comments":true,"path":"2019/11/19/2019-11-17-JavaScript-16/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/19/2019-11-17-JavaScript-16/","excerpt":"","text":"如果我想要複製物件的值，卻不希望在複製後，只要更動其值，原變數也會受到影響，該怎麼做呢？ 本篇將介紹關於 JavaScript 中的「淺拷貝」以及「深拷貝」。 原始型別在賦值時一般是直接傳值的方式(pass by value)： 123456let a= 1;let b = a;b = 2;console.log(a); //1console.log(b); //2 但是物件會是傳指標(pass by Reference)： 123456let obj1 = &#123; a:1, b:2, c:3&#125;;let obj2 = obj1;obj2.b = 4​console.log(obj1) //&#123; a:1, b:4, c:3&#125; console.log(obj2) //&#123; a:1, b:4, c:3&#125; 淺拷貝 Shallow Copy原本 a 和 b 是指向同一塊記憶體位址；透過重新賦值的方式，讓 b 指向一個新的記憶體位址： 123456789var a = &#123;name: 'William'&#125;var b = a;b = &#123;name: \"Teddy\"&#125;;console.log(a.name); // Williamconsole.log(b.name); // Teddy 同樣的範例還有這個，我們直接把 a 取出的值放到屬性名稱後面： 12345678910var a = &#123;name: 'William', age: 70&#125;;var b = &#123;name: a.name, age: a.age&#125;;b.name = \"Teddy\";console.log(a.name); // Williamconsole.log(b.name); // Teddy 也可以使用 Object.assign 的方式來複製： 12345var a = &#123;name: 'William', age: 70&#125;;var b = Object.assign(&#123;&#125;, a);b.name = \"Teddy\";console.log(a.name); // Williamconsole.log(b.name); // Teddy 但是以上使用淺拷貝只能複製一層。 當拷貝到第二層的時候就會發生問題： 1234567891011121314151617181920212223var obj = &#123; a: 1, b: &#123; b1: 2, b2: 3 &#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj);obj2.a= 10;obj2.b.b1= 20;console.log(obj.a); // 1console.log(obj.b.b1); // 20 物件 obj2 改變 a 並不會影響物件 obj 的 a ，但是改變再深一層的物件的值，就會影響到原本 a 的 b.b1 了! 讓我們在看一個例子： 12345678let obj1 = &#123;a:&#123;b:5&#125;&#125;;let obj2 = &#123;a:obj1.a&#125;;//都把a指派到&#123;b:5&#125;這個物件的referenceobj2.a.b = 10​console.log(obj1) //&#123;a:&#123;b:10&#125;&#125;; 被指派到10console.log(obj2) //&#123;a:&#123;b:10&#125;&#125;; console.log(obj1 === obj2) //false 實際上不是同物件 console.log(obj1.a === obj2.a) //true 但是第二層物件實際上相同 當我們要確保物件是整個複製，而不是只複製 reference 時就需要用到 Deep Copy 。 深拷貝 Deep CopyJSON.parse(JSON.stringify(object_array)): JSON.parse():把字串轉成物件 JSON.stringify():把物件轉成字串。 我們可以把物件先轉換成 JSON 再 parse 回來 123456789101112131415var obj = &#123; a: 1, b: &#123; b1: 2, b2: 3 &#125; &#125;;var obj2 = JSON.parse(JSON.stringify(obj));obj2.a= 10;obj2.b.b1= 20;console.log(obj.a); // 1console.log(obj.b.b1); // 2 也可以透過使用第三方套件(ex: JQuery、lodash)的方式： Lodash123456789var obj = &#123; a: 1, b: &#123; b1: 2, b2: 3 &#125;&#125;;var obj2 = cloneDeep(obj); Jquery深拷貝和淺拷貝對應的參數是 true 或 false 。預設情況是 false（淺拷貝），而且 false 不能夠寫出來，也就是你想要淺拷貝，那就什麼參數都不用帶。如果想帶入參數，只能傳入 true（深拷貝）。 12345678910111213141516171819var obj = &#123;&#125;;var obj2 = &#123; a: 1, b: &#123; b1: 2, b2: 3 &#125;&#125;;// 深拷貝$.extend(true, obj, obj2);obj.b.b1= 20;// b 並沒有因為 a 的改動也跟著改動console.log(obj2.b.b1); // 2// 至於沒有加上參數就是淺拷貝$.extend(obj,obj2); 參考文獻 https://ithelp.ithome.com.tw/articles/10200860 https://dustinhsiao21.com/2018/01/07/javascript-shallow-copy-and-deep-copy/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript THIS","slug":"2019-11-18-JavaScript-17","date":"2019-11-17T16:00:00.000Z","updated":"2019-12-08T02:52:31.960Z","comments":true,"path":"2019/11/18/2019-11-18-JavaScript-17/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/18/2019-11-18-JavaScript-17/","excerpt":"","text":"this 是 JavaScript 的一個關鍵字， this 會在不同的情境下指稱到不同的物件。 this 在物件導向裡面，它所代表的就是那個 instance 本身： 1234567891011121314class Car &#123; setName(name) &#123; this.name = name &#125; getName() &#123; return this.name &#125;&#125;const myCar = new Car()myCar.setName('Ford')console.log(myCar.getName()) // Ford 在上面我們宣告了一個 class Car，寫了 setName 跟 getName 兩個方法，在裡面用this.name來取放這個 instance 的屬性，myCar.setName(&#39;Ford&#39;)，所以 this 就會是myCar。 this 不等於 function如果直接調用函式，此函式的 this 會指向 window 。 123456window.say = 'Hi';function CallSay() &#123; console.log(this.say); // Hi&#125;CallSay(); this 不會指到 CallSay 這個 function，實際上是指向 window 。 再看一個範例： 123456789var call = function() &#123; console.log( this.name );&#125;;var say = function() &#123; var name = 'Felix'; this.call();&#125;;say(); 在這個範例中， say 可以透過 this.call 取得 call ，是因為 this.call 實際上是指向 window.call。而 call 的 this.name 並非是 say 中的 Felix ，而是指向 window.name ，所以會得到 undefined 的結果。 下個例子是將 function 內在包覆著 function，但只要是直接呼叫，this 都是屬於全域。 123456789101112window.say = 'Hi';function CallSay () &#123; console.log('call:', this.say); //call: Hi // function 內的 function function CallSayNow () &#123; console.log('call me now:', this.say);//call me now: Hi &#125; CallSayNow();&#125;CallSay(); 來看一下巢狀迴圈中的 this ： 1234567891011121314151617var obj = &#123; func1: function()&#123; console.log(this); //指到 func1 var func2 = function()&#123; // 這裡的 this 跟上層不同！ console.log(this);// 指到 window &#125;; func2(); &#125;&#125;;obj.func1(); 在 obj.func1() 裡面的 this 會指向 func1 ；是因為 func1 透過 obj 來呼叫的。 但 obj.func1() 裡面的 func2() 在執行時的 this 卻會指向 window。 也就是當沒有特定指明 this 的情況下，預設綁定 (Default Binding) this 為 「全域物件」，也就是 window。 以上這幾種情況， this 的值在瀏覽器底下就會是 window ，在 node.js 底下會是 global ，如果是在嚴格模式，this 的值就會是 undefined 。 強制指定 this 的方式在 JavaScript 有三個可以強制指定 this 的方式，分別是 call() 、 apply() 以及 bind()。 call 跟 apply 是很類似的方法，這兩種都是能夠呼叫 fucntion 的函式 1234567891011'use strict';function funA(a, b)&#123; console.log(this, a, b)&#125;funA(1, 2) // undefined 1 2funA.call(\"Hector\", 1, 2) // Hector 1 2funA.apply(\"Ray\", [1, 2]) // Ray 1 2 因為是嚴格模式所以 funA(1, 2) 的 this 是 undefined。 call 和 apply 就是你第一個參數傳什麼，裡面 this 的值就會是什麼。儘管原本已經有 this，也依然會被覆蓋： 而兩者的差別只在於 apply 傳進去的參數是一個 array，所以上面這三種呼叫 function 的方式是等價的。除了直接呼叫 function 以外，你也可以用 call 或是 apply 去呼叫，差別在於傳參數的方式不同。 除了以上兩種以外，還有最後一種可以改變 this 的方法：bind。12345678'use strict';function funA() &#123; console.log(this)&#125;const myFunA = funA.bind('Hi')myFunA() // Hi 在這邊我們把 funA 這個 function 用 Hi 來綁定，所以最後呼叫 myFunA 時會輸出 Hi 。 在看一個例子： 12345678910111213var obj = &#123; LastName: \"Lincoln\"&#125;;var func = function () &#123; console.log(this.LastName);&#125;;func(); // undefinedfunc.bind(obj)(); // Lincoln 加上了 bind 之後的 func.bind(obj)() ，會替我們將 func 的 this 暫時指向我們所設定的 obj。於是 console.log(this.LastName) 的結果自然就是 obj.LastName 也就是 Lincoln 了。 重新指向 this假設我們今天在某個元素上透過 addEventListener 註冊了 click 事件，而在事件中的 this 指的是「觸發事件的元素」。 要是我們在事件的 callback function 加入 ajax 的請求，那麼根據前面所說的，預設綁定 (Default Binding) 會把這個 callback function 的 this 指定給 global object ，也就是 window 。 如果需調用的則是物件本身的話，可以先用一個變數指向 this，等到調用後再重新使用它。 123456789101112el.addEventListener(\"click\", function(event) &#123; // 透過 that 參考 var that = this; console.log( this.textContent ); $ajax('[URL]', function(res) &#123; // this.textContent =&gt; undefined console.log(that.textContent, res); &#125;);&#125;, false); 像這樣，我們將事件內的 this 先用一個叫 that 的變數儲存它的參考，那麼在 ajax 的 callback function 就可以透過 that 來存取到原本事件中的 this 了。 如果我們把 call 跟 bind 同時用會怎樣!? 123456'use strict'; function funA() &#123; console.log(this) &#125; const myFunA = funA.bind('Hi') myFunA.call('Hello') // Hi 答案是不會改變，一但 bind 了以後值就不會改變了。 在非嚴格模式底下，無論是用 call、apply 還是 bind，你傳進去的如果是基本型別都會被轉成 object 。 舉例來說： 123456function funA() &#123; console.log(this) &#125; funA.call(1) // Number &#123;1&#125; const myFunA = funA.bind('Hi') myFunA() // String &#123;\"Hi\"&#125; 物件中的 this最前面我們示範了在物件導向 class 裡面的 this，但在 JavaScript 裡面還有另外一種方式也是物件： 1234567891011const obj = &#123; value: 1, say: function() &#123; console.log(this.value) &#125;&#125;obj.say() // 1const hello = obj.sayhello() // undefined 這種跟一開始的物件導向範例不太一樣，這個範例是直接創造了一個物件而沒有透過 class，所以你也不會看到 new 這個關鍵字的存在。 舉個簡單的例子來幫大家複習一下 Scope Chain： 12345678910111213141516171819202122232425262728293031var value = 1function say()&#123; console.log(value)&#125;const obj = &#123; value: 'value', say1: function() &#123; console.log(this.value); // value say() // 1 &#125;, say2: function() &#123; console.log(this.value); // value var value = 2 say() // 1 &#125;&#125;say() // 1obj.say1()obj.say2() 無論怎麼呼叫 say 這個 function，印出來的 value 永遠都會是全域變數的 value ，因為 say 在自己的作用域底下找不到 value 於是往上一層找，就會找到 global scope ，這跟你在哪裡呼叫 say 一點關係都沒有。 say 這個 function 在「定義」的時候就把 scope 給決定好了。 但 this 卻是完全相反，this 的值會根據你怎麼呼叫它而變得不一樣，像是先前我們剛講過的 call、apply 跟 bind ，你可以用不同的方式去呼叫 function，讓 this 的值變得不同。 this 的值跟作用域跟程式碼的位置在哪裡完全無關，只跟「如何呼叫」有關。 讓我們看複雜一點的例子： 123456789101112131415161718192021222324const obj = &#123; value: 1, say: function() &#123; console.log(this.value) &#125;, func2: &#123; value: 2, say: function() &#123; console.log(this.value) &#125; &#125;&#125;const obj2 = obj.func2const say= obj.func2.sayobj.func2.say()obj2.say()say() say 因為沒有傳參數進去，所以是預設綁定，在非嚴格模式底下是 window ，所以會 window.value 也就是 undefined 。 可以透過把 function 的呼叫轉成用 call 的形式，就會較容易看出 this 的值是什麼。 123obj.func2.say() // obj.func2.say.call(obj.func2) =&gt; 2obj2.say() // obj2.say.call(obj2) =&gt; 2say() // say.call() =&gt; undefined 箭頭函式的 this從 ES6 開始新增了一種叫做 「箭頭函式表示式」 (Arrow Function expression) 的函式表達式。 而箭頭函式有兩個重要的特性： 更簡短的函式寫法 this 變數強制綁定 ES6 新增的箭頭函式中的 this 有不一樣的運作方式，只要記住「在宣告它的地方的 this 是什麼，它的 this 就是什麼」，什麼意思呢？讓我們看個範例： 123456789101112131415161718192021222324252627const obj = &#123; Firstname: \"Vincent\", say: function()&#123; // 這邊印出來的 this 是什麼，func1 的 this 就會是什麼 // 在宣告它的地方的 this 是什麼，func1 的 this 就是什麼 console.log(this) const func1 = () =&gt; &#123; console.log(this.Firstname) &#125; func1() &#125;&#125;obj.say() // &#123;Firstname: \"Vincent\", say: ƒ&#125;// Vincentconst say = obj.saysay() // Window// undefined 我們在 say 這個 function 裡面宣告了 func1 這個箭頭函式，所以 say 的 this 是什麼， func1 的 this 就會是什麼。 箭頭函式的 this 不是取決於在宣告時那個地方的 this。 參考文獻 https://blog.techbridge.cc/2019/02/23/javascript-this/ https://ithelp.ithome.com.tw/articles/10193193 https://wcc723.github.io/javascript/2017/12/12/javascript-this/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript Closure","slug":"2019-11-16-JavaScript-15","date":"2019-11-16T16:00:00.000Z","updated":"2019-11-17T06:54:07.323Z","comments":true,"path":"2019/11/17/2019-11-16-JavaScript-15/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/17/2019-11-16-JavaScript-15/","excerpt":"","text":"Scope Chain在開始談閉包之前，我們現來談談「範圍鏈」(Scope Chain) 的觀念。 Scope Chain(範圍鏈)的特性，是指使用變數的時候，會遵循著 Scope Chain 一層一層往外找，也就是看看函式自身的 context 物件上是否有該特性，如果沒有就往外頭的 context 物件看看有沒有該特性。 用 var 所宣告的變數，作用範圍是在當時所在環境(函式內)，而不使用 var 直接指定值而建立的變數，則是全域物件(window)上的一個屬性，也就全域範圍。 例如像下面這段程式碼： 1234567var myVar = \"outer\";function func()&#123; console.log(myVar); // outer myVar = \"inner\";&#125;func();console.log(myVar); // inner func 的變數myVar 因為沒有使用 var 進行宣告，所以 myVar 會變成「全域變數」。 修改一下上面範例，若是在func 中的 myVar，有透過 var 宣告時，變數就會作用在當時的環境，也就是 func 。 由於 JavaScript 提升 (Hoisting)的特性，Hoisting 是 JavaScript 的預設行為，把所有宣告效果提到當前 Scope 的頂端，也就是變數可以在宣告之前進行初始化和使用，而不會拋錯： 1234567var myVar = \"outer\"; function func()&#123; console.log(myVar); // undefined var myVar = \"inner\";&#125;func();console.log(myVar); // outer func 運作上等同於： 12345function func()&#123; var myVar; console.log(myVar);// undefined myVar = \"inner\";&#125; 讓我們在看一個例子，每一個 function 執行的時候都會建立一個新的 context，所以 func 和 fund 各自為獨立的一個 Function execution context(執行環境)： 123456789101112var myVar = \"outer\";//另外一個執行環境function func()&#123; console.log(myVar); // outer&#125;//一個執行環境function fund()&#123; var myVar = \"inner\"; func();&#125;fund(); 當 fund 呼叫 func 時，由於 fund 和 func 都處於全域的環境，而 myVar 變數是被定義在 fund 的函式裡面；當你試圖在 func 中 使用 myVar 變數時，它會查看 func 的 context 物件上是否有該特性，如果有就使用，沒有就往外面一層找。由於 func 的上一層是 global context ，所以就存取到全域變數的 myVar，最終印出的結果就會是 outer 。 如果函式 func 的位置是被 fund 所包裹，當 func 找不到 myVar ，就會往它的向外一層找；所以就存取到 fund 裡面的 myVar ，輸出 inner 。 123456789101112var myVar = \"outer\";function fund()&#123; var myVar = \"inner\"; func(); function func()&#123; console.log(myVar); // inner &#125;&#125;fund(); 閉包 Closure閉包是個特殊的物件，他包含了一個函式，以及函式被建立時所在的環境。 在 JavaScript 中，只要有巢狀的函數定義，就會形成閉包。因為內層的函數需要引用到外層函數中定義的變數（建立範圍鏈 Scope Chain），所以外層函數中變數的狀態就好像被內層函數「關閉」起來了。 12345678910111213141516function OuterFunction() &#123; // 一個局部變數 var outerVariable = 100; function InnerFunction() &#123; // 內部函數可以存取外部函式的變數 alert(outerVariable); &#125; // 返回一個內部函式，並創建一個 closure return InnerFunction;&#125;var innerFunc = OuterFunction();innerFunc(); // 100 上面例子中，OuterFunction() 執行時返回一個 function，同時自動創建了一個 closure 環境。closure 像是一個特殊的物件 (指定給了 innerFunc )，closure 中包含一個函數 InnerFunction ，以及函數 OuterFunction 執行當時的環境，讓你在函數返回後還是可以持續存取 closure 保存的環境 ，像是能存取 outerVariable 變數， outerVariable 變數不會因為函數返回後而被刪除。 在這個例子中，我們把 counter 封裝在 Counter() 當中，不但可以讓裡面的 counter 不會暴露在 global 環境造成變數衝突，也可以確保內部 counter 被修改： 123456789101112131415function Counter() &#123; var counter = 0; function IncreaseCounter() &#123; return counter += 1; &#125;; return IncreaseCounter;&#125;var counter = Counter();alert(counter()); // 1alert(counter()); // 2alert(counter()); // 3alert(counter()); // 4 如果我們需要新增另一個計數器的話，透過一個閉包可以很輕鬆地達成： 12345678910111213141516171819function Counter() &#123; var counter = 0; function IncreaseCounter() &#123; return counter += 1; &#125;; return IncreaseCounter;&#125; var counter = Counter(); var counter2 = Counter(); alert(counter()); // 1 alert(counter()); // 2 alert(counter()); // 3 alert(counter2()); // 1 alert(counter2()); // 2 counter 與 counter2 各自是「獨立」的計數器實體，彼此不會互相干擾。 參考文獻 https://ithelp.ithome.com.tw/articles/10193009 https://www.fooish.com/javascript/function-closure.html https://ithelp.ithome.com.tw/articles/10029457 https://ithelp.ithome.com.tw/articles/10199934 https://www.tutorialsteacher.com/javascript/closure-in-javascript","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript IIFEs","slug":"2019-11-16-JavaScript-13","date":"2019-11-15T16:00:00.000Z","updated":"2020-01-10T15:37:14.308Z","comments":true,"path":"2019/11/16/2019-11-16-JavaScript-13/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/16/2019-11-16-JavaScript-13/","excerpt":"","text":"IIFEs立即被呼叫的函式 (Immediately Invoked Function Expression, IIFE)， Immediately 是立即的意思，invoked 則是執行某個函式時，「執行」的意思，function expression 是一種用來建立 function 的方法，總括來說，就是用 function expression 的方式建立函式後並立即執行它。 Function Statement 和 Function Expression以下為 Function Statement 和 Function Expression 的範例： 12345678910111213141516// function statementfunction fn1(num) &#123; console.log(num);&#125;fn1(1);// function expressionvar fn2= function(num) &#123; console.log(num);&#125;fn2(2); 先來看一下範例，印出 fn1() 的內容： 123456// function expressionvar fn1 = function(num) &#123; console.log(num);&#125;console.log(fn1); 呼叫 fn1() 後，它會回傳整個函式的內容，這是尚未 執行（Invoked）的結果。 如果是 IIFEs 就在這段程式碼的最後，加上一個執行的指令，也就是括號 ( )： 123var fn1 = function(num) &#123; console.log(num);&#125;(10); 在我們建立函式的同時，這段函式就會立即被執行了，印出 10 。 試著把 function 裡面的 console.log 改成 return原本 function expression 的程式碼如下： 12345// function expressionvar fn1 = function(num) &#123; return(num);&#125;console.log(fn1); 可以發現結果還是一個函式： 如果把它改成 IIFEs 的話，就會得到 10 ： 123456// Immediately Invoked Functions Expressions (IIFEs)var fn1 = function(num) &#123; return(num);&#125;(10);console.log(fn1); 在利用 IIFE 的寫法後，原本的變數 fn1 已經變成函式執行後回傳的「Number」，它已經是數字而不是 function ，如果還使用 () 去 Invoke(執行) 的話會出現錯誤。 12345// Immediately Invoked Functions Expressions (IIFEs)var fn1 = function(num) &#123; return(num);&#125;(10);console.log(fn1()); 產生錯誤： 下面的範例，我們建立了一個匿名函式，並且透過 IIFEs 馬上執行： 123456789var value= 1;(function(num) &#123; var value= 3; console.log(value) console.log(num);&#125;)(2);console.log(value); 以下為執行結果： 123321 由執行結果可看到，在IIFEs中所建立的變數，不會影響到 Global Execution Context 所建立的變數，也就是說，透過IIFEs，達成不同 execution context 的變數之間不會互相影響。 不過我們可以透過填入物件 window ，直接針對 window 裡面的物件去做改變： 1234567891011var value= 1;(function(global,num) &#123; var value= 3; //透過 global 去修改外面的 value global.value=4; console.log(value) console.log(num);&#125;)(window,2);// 新增一個參數 windowconsole.log(value); 結果如下，成功變更在 Global Execution Context 的 value 為 4： 123324 參考文獻 https://pjchender.blogspot.com/2016/05/javascriptiifesimmediately-invoked.html https://pjchender.blogspot.com/2016/05/iifesimmediately-invoked-functions.html https://dotblogs.com.tw/h20/2019/03/06/162305","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript Callback Function","slug":"2019-11-16-JavaScript-14","date":"2019-11-15T16:00:00.000Z","updated":"2020-01-10T15:35:50.831Z","comments":true,"path":"2019/11/16/2019-11-16-JavaScript-14/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/16/2019-11-16-JavaScript-14/","excerpt":"","text":"Callback Function把函式當作另一個函式的參數，透過另一個函式來呼叫它，他可以「控制多個函式間執行的順序」。 來看個例子，首先定義兩個 function ，因為 function 會立即執行，所以先印出 1 ，在印出 2 ： 123456789function first()&#123; console.log(1);&#125;function second()&#123; console.log(2);&#125;first();//1second();//2 透過 setTimeout 讓 first() 設定延遲 500毫秒 在執行， JavaScript 不會等待 first() 執行完才執行 second() ；所以就算我們先呼叫了 first() ，也會是 second() 先被執行，結果就會是先印出 2 ，在印出 1 ： 1234567891011121314function first()&#123; // Simulate a code delay setTimeout( function()&#123; console.log(1); &#125;, 500 );&#125;function second()&#123; console.log(2);&#125;first();second();//2//1 像這種時候，為了確保執行的順序，就會透過 Callback function 的形式來處理： 123456789101112131415161718// 為了確保先執行 first 再執行 second// 我們在 first 加上 callback 參數var first=function(callback)&#123; setTimeout(function()&#123; console.log(1); callback(); &#125;, 500);&#125;;var second=function()&#123; console.log(2);&#125;;// 將 second 作為參數帶入 first()first(second);//1//2 像這樣，無論 first 在執行的時候要等多久， second 都會等到 console.log(1); 之後才執行。 另一個例子： 1234567891011function doHomework(subject, callback) &#123; alert(`Starting my $&#123;subject&#125; homework.`); callback();&#125;function alertFinished()&#123; alert('Finished my homework');&#125;doHomework('math', alertFinished);//Starting my math homework.//Finished my homework 不過需要注意的是，當函式之間的相依過深，callback 多層之後產生的「Callback Hell」維護起來就會很複雜。 參考文獻 https://ithelp.ithome.com.tw/articles/10192739 https://codeburst.io/javascript-what-the-heck-is-a-callback-aba4da2deced","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"DOM - 事件處裡及傳遞機制","slug":"2019-11-14-JavaScript-12","date":"2019-11-14T16:00:00.000Z","updated":"2020-01-10T15:38:17.502Z","comments":true,"path":"2019/11/15/2019-11-14-JavaScript-12/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/15/2019-11-14-JavaScript-12/","excerpt":"","text":"這篇教學介紹瀏覽器事件的運作原理，包含 EventTarget 、 Event Bubbling 、 Event Capturing 、 Event Delegation 。 Event Flow事件流程 (Event Flow) 指的就是「網頁元素接收事件的順序」。 事件流程可以分成兩種機制： 事件冒泡 (Event Bubbling) 事件捕獲 (Event Capturing) 事件冒泡 (Event Bubbling)Event Bubbling 指的是當某個事件發生在某個 DOM element 上（如：點擊），這個事件會觸發 DOM element 的 event handler ，接下來會再觸發他的 parent 的 event handler ，以及 parent 的 parent 的 event handler …直到最上層。 圖片來源： Event Flow: capture, target, and bubbling 事件冒泡指的是「從啟動事件的元素節點開始，逐層往上傳遞」，直到整個網頁的根節點，也就是 document。 事件捕獲 (Event Capturing)和 Event Bubbling 相反， event 發生在某個 DOM element 上的時候，會從他的最上層 parent 開始觸發 event handler ，再來是倒數第二上層的 event handler ，以此類推，直到觸發事件的 DOM element 本身的 event handler 。 圖片來源： Event Flow: capture, target, and bubbling 事件捕獲則和事件冒泡機制相反。 例如我們看這一個 HTML DOM 結構： 123456789101112&lt;html&gt;&lt;head&gt; &lt;title&gt;event flow example&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 當使用者點擊 li 元素時，事件觸發的順序是： Capturing 捕獲階段：Document -&gt; &lt;html&gt; -&gt; &lt;body&gt; -&gt; &lt;div&gt; -&gt; &lt;ul&gt; -&gt; &lt;li&gt; Bubbling 氣泡階段：&lt;li&gt; -&gt; &lt;ul&gt; -&gt; &lt;div&gt; -&gt; &lt;body&gt; -&gt; &lt;html&gt; -&gt; Document 要檢驗事件流程，我們可以透過 addEventListener() 方法來綁定 click 事件，透過 addEventListener 指定事件的綁定，第三個參數 true / false 分別代表捕獲/ 冒泡 機制，不加參數的話，預設值是 false： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;ul id=\"list\"&gt; &lt;li id=\"list_item\"&gt; &lt;a id=\"list_item_link\" target=\"_blank\" href=\"https://cheng-yi-ting.github.io/\"&gt; Click link! &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt;var list = document.getElementById('list');var list_item = document.getElementById('list_item');var list_item_link = document.getElementById('list_item_link');// list 的捕獲list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing', e.eventPhase);&#125;, true)// list 的冒泡list.addEventListener('click', (e) =&gt; &#123; console.log('list bubbling', e.eventPhase);&#125;, false)// list_item 的捕獲list_item.addEventListener('click', (e) =&gt; &#123; console.log('list_item capturing', e.eventPhase);&#125;, true)// list_item 的冒泡list_item.addEventListener('click', (e) =&gt; &#123; console.log('list_item bubbling', e.eventPhase);&#125;, false)// list_item_link 的捕獲list_item_link.addEventListener('click', (e) =&gt; &#123; console.log('list_item_link capturing', e.eventPhase);&#125;, true)// list_item_link 的冒泡list_item_link.addEventListener('click', (e) =&gt; &#123; console.log('list_item_link bubbling', e.eventPhase);&#125;, false) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 點一下超連結，console 輸出以下結果： 123456list capturing 1list_item capturing 1list_item_link capturing 2list_item_link bubbling 2list_item bubbling 3list bubbling 3 1 是CAPTURING_PHASE，2 是AT_TARGET，3 是BUBBLING_PHASE。 從這邊就可以很明顯看出，事件的確是從最上層一直傳遞到 target，再從 target 不斷冒泡傳回去，先傳到上一層的#list_item，再傳到上上層的#list。 事件傳遞到我們點擊的超連結（a#list_item_link）本身，在這邊無論你使用addEventListener的第三個參數是true還是false，這邊的e.eventPhase都會變成AT_TARGET。 Capturing 或 Bubbling 的目標執行順序既然是先捕獲，再冒泡，意思就是無論那些addEventListener的順序怎麼變，輸出的東西應該還是會一樣才對。我們把捕獲跟冒泡的順序對調，看一下輸出結果是否一樣。 1234567891011121314151617181920212223242526272829// list 的冒泡list.addEventListener('click', (e) =&gt; &#123; console.log('list bubbling', e.eventPhase);&#125;, false)// list 的捕獲list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing', e.eventPhase);&#125;, true)// list_item 的冒泡list_item.addEventListener('click', (e) =&gt; &#123; console.log('list_item bubbling', e.eventPhase);&#125;, false)// list_item 的捕獲list_item.addEventListener('click', (e) =&gt; &#123; console.log('list_item capturing', e.eventPhase);&#125;, true)// list_item_link 的冒泡list_item_link.addEventListener('click', (e) =&gt; &#123; console.log('list_item_link bubbling', e.eventPhase);&#125;, false)// list_item_link 的捕獲list_item_link.addEventListener('click', (e) =&gt; &#123; console.log('list_item_link capturing', e.eventPhase);&#125;, true) 點一下超連結，console 輸出以下結果： 123456list capturing 1list_item capturing 1list_item_link bubbling 2list_item_link capturing 2list_item bubbling 3list bubbling 3 list_item_link先執行了添加在冒泡階段的 listener，才執行捕獲階段的 listener。 前面有提到，當事件傳遞到點擊的真正對象，也就是 e.target 的時候，無論addEventListener的第三個參數是true還是false，這邊的e.eventPhase都會變成AT_TARGET。 既然已經是AT_TARGET，就不會區分捕獲跟冒泡，執行順序會根據addEventListener的順序來決定，先添加的先執行，後添加的後執行。 關於這些事件的傳遞順序，只需記住兩個原則： 先捕獲，再冒泡 當事件傳到 target 本身，沒有分捕獲跟冒泡 阻擋事件冒泡傳遞 event.stopPropagation()如果我們想要阻擋事件向上冒泡傳遞，那麼就可以利用 event object 提供的另一個方法： event.stopPropagation() ，讓事件的傳遞中斷，不會繼續往下傳遞。 根據上面的例子，我添加 event.stopPropagation() 至 #list 的捕獲階段： 12345// list 的捕獲list.addEventListener('click', (e) =&gt; &#123; console.log('list capturing', e.eventPhase); e.stopPropagation();&#125;, true) 點一下超連結，console 輸出以下結果： 1list capturing 1 因為事件的傳遞被停止，所以剩下的 listener 都不會再收到任何事件。 如果在同一個節點上不只一個 listener，其他 listener 還是會被執行。 12345678910// list 的捕獲 Alist.addEventListener('click', (e) =&gt; &#123; console.log('list capturing-A'); e.stopPropagation();&#125;, true)// list 的捕獲 Blist.addEventListener('click', (e) =&gt; &#123; console.log('list capturing-B');&#125;, true) 點一下超連結，console 輸出以下結果： 12list capturing-Alist capturing-B 如果要讓其他同一層級的 listener 也不要被執行，可以使用 e.stopImmediatePropagation() ： 12345678910// list 的捕獲 Alist.addEventListener('click', (e) =&gt; &#123; console.log('list capturing-A'); e.stopImmediatePropagation();&#125;, true)// list 的捕獲 Blist.addEventListener('click', (e) =&gt; &#123; console.log('list capturing-B');&#125;, true) 點一下超連結，console 輸出以下結果： 1list capturing-A 阻擋預設行為 event.preventDefault()HTML 部分元素會有預設行為，像是 &lt;a&gt; 的連結，或是表單的 submit 等等…，如果我們需要在這些元素上綁定事件，那麼可以透過 event.preventDefault() 來取消它們的預設行為。 1234// list_item_link 的冒泡list_item_link.addEventListener('click', (e) =&gt; &#123; e.preventDefault();&#125;, false) 當點擊超連結的時候，就不會執行原本預設的行為（新開分頁）。event.preventDefault()在之後傳遞下去的事件裡面也會有效果。 12345&#x2F;&#x2F; list 的捕獲 Alist.addEventListener(&#39;click&#39;, (e) &#x3D;&gt; &#123; console.log(&#39;list capturing-A&#39;); e.preventDefault(); &#125;, true) 就算是把 event.preventDefault() 添加到 #list 的捕獲事件裡面，等之後事件傳遞到#list_item_link的時候，一樣可以取消超連結的預設行為（新開分頁）。 事件委派（Event Delegation）假設同時有很多 DOM element 都有相同的 event handler ，與其在每個 DOM element 上個別附加 event handler ，不如利用 event bubbling 的特性，統一在他們的 ancestor 的 event handler 處理，可以有效地減少監聽器數量。 假設有一個三個 li 節點的 ul ，接著動態產生剩下的節點資料： 12345&lt;ul id&#x3D;&quot;list&quot;&gt; &lt;li &gt;one&lt;&#x2F;li&gt; &lt;li &gt;two&lt;&#x2F;li&gt; &lt;li &gt;three&lt;&#x2F;li&gt;&lt;ul&gt; 雖然可以對個別的li附加 click event hander ，但有幾個li就要加幾次 addEventListener。我們可以透過 event delegation 的方式統一管理，任何點擊 li 的事件都傳到 ul ，因此我們可以在 ul 身上放一個 addEventListener。 以下例子為將點擊的 li 元素，設置 hidden 屬性： 123456789101112131415161718192021222324252627 var list = document.getElementById('list'); list.addEventListener('click', function (e) &#123; //點擊元素後，該元素隱藏 e.target.style.visibility = 'hidden'; // e.target refers to the clicked &lt;li&gt; element // This is different than e.currentTarget which would refer to the parent &lt;ul&gt; in this context console.log(e.target.tagName);//LI console.log(e.currentTarget.tagName);//UL //this 代表的會是「觸發事件的目標」元素，也就是 event.currentTarget 而不是 e.target。 console.log(this.tagName);//UL&#125;, false); // 取得 #list ulvar List = document.getElementById('list'); for (var i = 0; i &lt; 10; i++) &#123; // 建立 li 標籤 var node = document.createElement(\"LI\"); // 建立 文字節點 var textnode = document.createTextNode(i); // 透過 appendChild 將 文字節點 加入至 List node.appendChild(textnode); document.getElementById(\"list\").appendChild(node); &#125; 輸出結果： one two three 0 1 2 3 4 5 6 7 8 9 當新增或刪除一個 li 的時候，無需去處理和那個元素相關的 listener ，因為 listener 是放在 ul ，透過父節點來處理子節點的事件，就稱為事件代理。 E.CURRENTTARGET VS. E.TARGETevent.currentTarget 屬性會指向目前於冒泡或捕捉階段正在處理該事件之事件處理器所註冊的 DOM 物件，而 event.target 屬性則是會指向觸發事件的 DOM 物件。 如果放置一個 event listener 到 p 節點， event.currentTarget 就會指到 p ， event.target 則還是指到 span ，如果把 event listener 放置到 body 上，則 event.currentTarget 就會指到 body ： 123456789&lt;p id&#x3D;&quot;list&quot;&gt; &lt;a href&#x3D;&quot;#&quot;&gt;some &lt;span&gt;text&lt;&#x2F;span&gt; &lt;&#x2F;a&gt;&lt;&#x2F;p&gt; 123456var list = document.getElementById('list'); list.addEventListener('click', function (e) &#123; console.log(e.target.tagName); console.log(e.currentTarget.tagName); &#125;, false); EventTarget.addEventListener()addEventListener 方法可以用來綁定元素的事件處理函數，有三個參數，分別是「事件名稱」、「事件的處理器」(事件觸發時執行的 function)，以及一個「Boolean」值，由這個 Boolean 決定事件是以「捕獲」或「冒泡」機制執行，若不指定則預設為「冒泡」。 事件監聽範例： 1234&lt;table id&#x3D;&quot;outside&quot;&gt; &lt;tr&gt;&lt;td id&#x3D;&quot;t1&quot;&gt;one&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt; &lt;tr&gt;&lt;td id&#x3D;&quot;t2&quot;&gt;two&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; addEventListener 可以對同一個元素指定多個事件處理函數，當點擊 li 元素時，跳出警告視窗，並執行 modifyText 函數；將 t2 的值 修改為 four ： 12345678910111213&#x2F;&#x2F; Function to change the content of t2function modifyText() &#123; var t2 &#x3D; document.getElementById(&quot;t2&quot;); t2.firstChild.nodeValue &#x3D; &quot;four&quot;; &#125;&#x2F;&#x2F; add event listener to tablevar el &#x3D; document.getElementById(&quot;outside&quot;);el.addEventListener(&quot;click&quot;, modifyText, false);el.addEventListener(&#39;click&#39;, function()&#123; alert(&#39;HI&#39;);&#125;, false); 可以修改為匿名函數的事件監聽： 1el.addEventListener(\"click\", function()&#123;modifyText(\"four\")&#125;, false); EventTarget.removeEventListener()取消透過 addEventListener 綁定的事件處理函數，三個參數與 addEventListener() 一樣，分別是「事件名稱」、「事件的處理器」以及「捕獲」或「冒泡」的機制。 但是需要注意的是，由於 addEventListener() 可以同時針對某個事件綁定多個 handler，所以透過 removeEventListener() 解除事件的時候，第二個參數的 handler 必須要與先前在 addEventListener() 綁定的 handler 是同一個「實體」。 123456var el &#x3D; document.getElementById(&quot;outside&quot;);el.addEventListener(&#39;click&#39;, function()&#123;alert(&#39;Hi&#39;);&#125;, false);&#x2F;&#x2F;remove event listenerel.removeEventListener(&#39;click&#39;,function()&#123;alert(&#39;Hi&#39;);&#125;, false); 即使執行了 removeEventListener 來移除事件，但 click 時仍會出現 ‘HI’。因為 addEventListener 與 removeEventListener 所移除的 handler 實際上是兩個不同實體的 function 物件。 需修改為以下： 123456789101112 var el = document.getElementById(\"outside\"); // 把 event handler 先存到變數 var clickHandler =function()&#123; alert('Hi'); &#125;; el.addEventListener('click', clickHandler, false); //成功移除 clickHandler el.removeEventListener('click',clickHandler, false); 參考文獻 https://blog.techbridge.cc/2017/07/15/javascript-event-propagation/ https://ithelp.ithome.com.tw/articles/10191970 https://ithelp.ithome.com.tw/articles/10192015 http://shubo.io/event-bubbling-event-capturing-event-delegation/ https://developer.mozilla.org/zh-TW/docs/Web/API/EventTarget/addEventListener https://developer.mozilla.org/zh-TW/docs/Web/API/Event/target http://www.qc4blog.com/?p=650","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://cheng-yi-ting.github.io/tags/HTML/"}]},{"title":"JavaScript DOM 查找元素","slug":"2019-11-14-JavaScript-10","date":"2019-11-13T16:00:00.000Z","updated":"2020-01-10T15:39:55.810Z","comments":true,"path":"2019/11/14/2019-11-14-JavaScript-10/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/14/2019-11-14-JavaScript-10/","excerpt":"","text":"DOM (Document Object Model) 定義了一組標準 API (Application Programming Interface) 讓我們可以用 JavaScript 對 HTML 文件做操作。 DOM 將一份 HTML 文件看作是一個樹狀結構的物件，讓我們可以方便直觀的存取樹中的節點 (node) 來改變其結構、樣式 (CSS) 或內容等。 document 物件是 DOM tree 的根節點，表示整份 HTML 文件，通常你要存取 HTML 都是從 document 物件開始： 圖片來源： Wikipedia DOM HTML DOM 規範中定義了這些類型的 API： 讓我們可以對 HTML 的元素 (element) 當作是 JavaScript 物件 (object) 來操作 定義了 HTML 元素有哪些屬性 (properties) 可以來做存取 定義了 HTML 元素有哪些方法 (methods) 可以來被操作 定義了 HTML 元素事件 (events)，讓我們可以針對特定元素來綁定事件處理函式 (例如使用者按下滑鼠、在鍵盤打字都是所謂的事件) document.getElementById(id)透過 id 取得一個 HTML 元素。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p id&#x3D;&quot;demo&quot;&gt;Click the button to change the text in this paragraph.&lt;&#x2F;p&gt;&lt;button onclick&#x3D;&quot;myFunction()&quot;&gt;Try it&lt;&#x2F;button&gt;&lt;script&gt;function myFunction() &#123; document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;Hello World&quot;;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; document.getElementsByTagName(name)用來根據 HTML 標籤 (tag) 名稱取得所有這個標籤的元素集合 (HTMLCollection)，返回的結果是一個像陣列 (array) 的物件。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;An unordered list:&lt;&#x2F;p&gt;&lt;ul&gt; &lt;li&gt;Coffee&lt;&#x2F;li&gt; &lt;li&gt;Tea&lt;&#x2F;li&gt; &lt;li&gt;Milk&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;p&gt;Click the button to display the innerHTML of the second li element (index 1).&lt;&#x2F;p&gt;&lt;button onclick&#x3D;&quot;myFunction()&quot;&gt;Try it&lt;&#x2F;button&gt;&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;&lt;script&gt;function myFunction() &#123; var x &#x3D; document.getElementsByTagName(&quot;LI&quot;); document.getElementById(&quot;demo&quot;).innerHTML &#x3D; x[1].innerHTML;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; document.getElementsByName(name)用來取得特定名稱 (name) 的 HTML 元素集合 (HTMLCollection)，返回的結果是一個像陣列 (array) 的物件。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;First Name: &lt;input name&#x3D;&quot;fname&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;Michael&quot;&gt;&lt;br&gt;First Name: &lt;input name&#x3D;&quot;fname&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;Doug&quot;&gt;&lt;p&gt;Click the button to get the tag name of the first element in the document that has a name attribute with the value &quot;fname&quot;.&lt;&#x2F;p&gt;&lt;button onclick&#x3D;&quot;myFunction()&quot;&gt;Try it&lt;&#x2F;button&gt;&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;&lt;script&gt;function myFunction() &#123; var x &#x3D; document.getElementsByName(&quot;fname&quot;)[0].tagName; document.getElementById(&quot;demo&quot;).innerHTML &#x3D; x;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; document.getElementsByClassName(names)用來取得特定類別名稱 (class name) 的 HTML 元素集合 (HTMLCollection)，返回的結果是一個像陣列 (array) 的物件。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div class&#x3D;&quot;example&quot;&gt;First div element with class&#x3D;&quot;example&quot;.&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;example&quot;&gt;Second div element with class&#x3D;&quot;example&quot;.&lt;&#x2F;div&gt;&lt;p&gt;Click the button to change the text of the first div element with class&#x3D;&quot;example&quot; (index 0).&lt;&#x2F;p&gt;&lt;button onclick&#x3D;&quot;myFunction()&quot;&gt;Try it&lt;&#x2F;button&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; The getElementsByClassName() method is not supported in Internet Explorer 8 and earlier versions.&lt;&#x2F;p&gt;&lt;script&gt;function myFunction() &#123; var x &#x3D; document.getElementsByClassName(&quot;example&quot;); x[0].innerHTML &#x3D; &quot;Hello World!&quot;;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 可以使用空白隔開多個 class name，元素必須有所有指定的 class name 才符合。例如： 123// 取得同時有 demo 和 test 兩個 class name 的所有元素document.getElementsByClassName('demo test'); document.querySelector(selectors)使用 CSS 選擇器 (CSS selectors) 來尋找符合條件且第一個找到的 HTML 元素。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2 class&#x3D;&quot;example&quot;&gt;A heading with class&#x3D;&quot;example&quot;&lt;&#x2F;h2&gt;&lt;p class&#x3D;&quot;example&quot;&gt;A paragraph with class&#x3D;&quot;example&quot;.&lt;&#x2F;p&gt; &lt;p&gt;Click the button to add a background color to the first element in the document with class&#x3D;&quot;example&quot;.&lt;&#x2F;p&gt;&lt;button onclick&#x3D;&quot;myFunction()&quot;&gt;Try it&lt;&#x2F;button&gt;&lt;script&gt;function myFunction() &#123; document.querySelector(&quot;.example&quot;).style.backgroundColor &#x3D; &quot;red&quot;;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; document.querySelectorAll(selectors)使用 CSS 選擇器 (CSS selectors) 來尋找所有符合條件的 HTML 元素集合 (NodeList)。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2 class&#x3D;&quot;example&quot;&gt;A heading with class&#x3D;&quot;example&quot;&lt;&#x2F;h2&gt;&lt;p class&#x3D;&quot;example&quot;&gt;A paragraph with class&#x3D;&quot;example&quot;.&lt;&#x2F;p&gt; &lt;p&gt;Click the button to add a background color all elements with class&#x3D;&quot;example&quot;.&lt;&#x2F;p&gt;&lt;button onclick&#x3D;&quot;myFunction()&quot;&gt;Try it&lt;&#x2F;button&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; The querySelectorAll() method is not supported in Internet Explorer 8 and earlier versions.&lt;&#x2F;p&gt;&lt;script&gt;function myFunction() &#123; var x, i; x &#x3D; document.querySelectorAll(&quot;.example&quot;); for (i &#x3D; 0; i &lt; x.length; i++) &#123; x[i].style.backgroundColor &#x3D; &quot;red&quot;; &#125;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; DOM tree 節點間位置的相互關係由於 DOM 節點有分層的概念，於是節點與節點之間的關係，我們大致上可以分成兩種： 父子關係：除了 document 之外，每一個節點都會有個上層的節點，我們通常稱之為「父節點」 (Parent node)，而相對地，從屬於自己下層的節點，就會稱為「子節點」(Child node)。 兄弟關係：有同一個「父節點」的節點，那麼他們彼此之間就是「兄弟節點」(Siblings node)。 圖片來源：重新認識 JavaScript: Day 12 透過 DOM API 查找節點 - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天 Node.childNodes所有的 DOM 節點物件都有 childNodes 屬性 (read-only property)，可以用來取得該元素下的所有子元素集合 (NodeList)。 12345678910111213var demo &#x3D; document.querySelector(&#39;#demo&#39;);&#x2F;&#x2F; 如果 node 內有子元素if( demo.hasChildNodes() ) &#123; &#x2F;&#x2F; 可以透過 demo.childNodes[n] (n 為數字索引) 取得對應的節點 &#x2F;&#x2F; 注意，NodeList 物件內容為即時更新的集合 for (var i &#x3D; 0; i &lt; demo.childNodes[i].length; i++) &#123; &#x2F;&#x2F; ... &#125;;&#125; Node.childNodes 回傳的可能會有這幾種： HTML 元素節點 (element nodes) 文字節點 (text nodes)，包含空白 註解節點 (comment nodes) Node.childrenDOM 節點物件的 children 屬性和 childNodes 屬性類似，差異在於 childNodes 返回的子元素會包含文字節點 (text nodes) 和註解節點 (comment nodes)，children 屬性則只會返回 HTML 元素節點 (HTMLCollection)。 Node.firstChildNode.firstChild 可以取得 Node 節點的第一個子節點，如果沒有子節點則回傳 null。 要注意的是，子節點包括「空白」節點，所以像下面範例： 123456789101112&lt;p&gt; &lt;span&gt;span 1&lt;&#x2F;span&gt; &lt;span&gt;span 2&lt;&#x2F;span&gt; &lt;span&gt;span 3&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;script&gt; var p &#x3D; document.querySelector(&#39;p&#39;); &#x2F;&#x2F; tagName 屬性可以取得 node 的標籤名稱 console.log(p.firstChild.tagName); &#x2F;&#x2F; undefined&lt;&#x2F;script&gt; 因為拿到的是 &lt;p&gt; 與第一個 &lt;span&gt; 中間的「換行字元」，所以 p.firstChild.tagName 會得到 undefined。 另一個例子： 123456789101112&lt;p id&#x3D;&quot;demo&quot;&gt; &lt;span&gt;First span&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;script&gt; var p &#x3D; document.getElementById(&#39;demo&#39;); &#x2F;&#x2F; 會顯示 &quot;#text&quot;，因為第一個子元素是換行字元 alert(p.firstChild.nodeName);&lt;&#x2F;script&gt; 可以把第一個例子修改成以下： 12345678&lt;p&gt;&lt;span&gt;span 1&lt;&#x2F;span&gt;&lt;span&gt;span 2&lt;&#x2F;span&gt;&lt;span&gt;span 3&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;script&gt; var p &#x3D; document.querySelector(&#39;p&#39;); &#x2F;&#x2F; tagName 屬性可以取得 node 的標籤名稱 console.log(p.firstChild.tagName); &#x2F;&#x2F; &quot;SPAN&quot;&lt;&#x2F;script&gt; 把中間的換行與空白移除，就會得到預期中的 &quot;SPAN&quot; 了。 第二個例子修改方式也一樣： 123456789&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;span&gt;First span&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;script&gt; var p &#x3D; document.getElementById(&#39;demo&#39;); &#x2F;&#x2F; 會顯示 &quot;SPAN&quot; alert(p.firstChild.nodeName);&lt;&#x2F;script&gt; Node.lastChildNode.lastChild 可以取得 Node 節點的最後一個子節點，如果沒有子節點則回傳 null。 與 Node.firstChild 一樣的是，子節點包括「空白」節點： 123456789&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;span&gt;First span&lt;&#x2F;span&gt;&lt;span&gt;Second span&lt;&#x2F;span&gt;&lt;span&gt;Last span&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;script&gt; var p &#x3D; document.getElementById(&#39;demo&#39;); &#x2F;&#x2F; 會顯示 &quot;Last span&quot; alert(p.lastChild.innerHTML);&lt;&#x2F;script&gt; Node.parentNode透過 Node.parentNode 可以用來取得父元素，回傳值可能會是一個元素節點 (Element node)、根節點 (Document node) 或 DocumentFragment 節點。 1234567891011&lt;p&gt; &lt;span id&#x3D;&quot;demo&quot;&gt;my span&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;script&gt; var elem &#x3D; document.getElementById(&#39;demo&#39;); &#x2F;&#x2F; 會顯示 &quot;P&quot; alert(elem.parentNode.nodeName);&lt;&#x2F;script&gt; Node.previousSibling透過 Node.previousSibling 可以取得同層之間的「前一個」節點，如果 node 已經是第一個節點，則回傳 null。 123456789&lt;div&gt;&lt;span id&#x3D;&quot;s1&quot;&gt;s1&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;s2&quot;&gt;s2&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;script&gt; &#x2F;&#x2F; 會顯示 null alert(document.getElementById(&#39;s1&#39;).previousSibling); &#x2F;&#x2F; 會顯示 &quot;s1&quot; alert(document.getElementById(&#39;s2&#39;).previousSibling.id);&lt;&#x2F;script&gt; 第二個例子： 1234567891011&lt;p&gt;&lt;span&gt;span 1&lt;&#x2F;span&gt;&lt;span&gt;span 2&lt;&#x2F;span&gt;&lt;span&gt;span 3&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;script&gt; var el &#x3D; document.querySelector(&#39;span&#39;); console.log( el.previousSibling ); &#x2F;&#x2F; null &#x2F;&#x2F; document.querySelectorAll 會取得所有符合條件的集合， &#x2F;&#x2F; 而 document.querySelectorAll(&#39;span&#39;)[2] 指的是「第三個」符合條件的元素。 var el2 &#x3D; document.querySelectorAll(&#39;span&#39;)[2]; console.log( el2.previousSibling.textContent ); &#x2F;&#x2F; &quot;span 2&quot;&lt;&#x2F;script&gt; Node.nextSibling透過 Node.previousSibling 可以取得同層之間的「下一個」節點，如果 node 已經是最後一個節點，則回傳 null。 123456789&lt;div&gt;&lt;span id&#x3D;&quot;s1&quot;&gt;s1&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;s2&quot;&gt;s2&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;script&gt; &#x2F;&#x2F; 會顯示 &quot;s2&quot; alert(document.getElementById(&#39;s1&#39;).nextSibling.id); &#x2F;&#x2F; 會顯示 null alert(document.getElementById(&#39;s2&#39;).nextSibling);&lt;&#x2F;script&gt; 第二個例子： 12345678&lt;p&gt;&lt;span&gt;span 1&lt;&#x2F;span&gt;&lt;span&gt;span 2&lt;&#x2F;span&gt;&lt;span&gt;span 3&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;script&gt; &#x2F;&#x2F; document.querySelector 會取得第一個符合條件的元素 var el &#x3D; document.querySelector(&#39;span&#39;); console.log( el.nextSibling.textContent ); &#x2F;&#x2F; &quot;span 2&quot;&lt;&#x2F;script&gt; 上面介紹的很多 DOM 查找方式會返回一個元素集合，是一個像陣列的物件 - 有 length 屬性、可以用 for 迴圈遍歷結果，雖然不能使用陣列型別的 method，但這兩種都可以用「陣列索引」的方式來存取內容。 而 NodeList 和 HTMLCollection 的差別在於，NodeList 包含任何的節點類型，除了 HTML element 節點，也包含文字節點、屬性節點等。HTMLCollection 則只包含 HTML 元素節點 (Element nodes)。 像是 document.getElementsBy** (注意，有個 s) 以及 document.querySelectorAll 分別回傳 「HTMLCollection」 與 「NodeList」。 另一個需要注意的地方是，HTMLCollection / NodeList 在大部分情況下是即時更新的，但透過 document.querySelectorAll 會回傳一個靜態的 NodeList。 1234567891011121314151617181920&lt;div id&#x3D;&quot;outer&quot;&gt; &lt;div id&#x3D;&quot;inner&quot;&gt;inner&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt; &#x2F;&#x2F; &lt;div id&#x3D;&quot;outer&quot;&gt; var outerDiv &#x3D; document.getElementById(&#39;outer&#39;); &#x2F;&#x2F; 所有的 &lt;div&gt; 標籤 var allDivs &#x3D; document.getElementsByTagName(&#39;div&#39;); console.log(allDivs.length); &#x2F;&#x2F; 2 &#x2F;&#x2F; 清空 &lt;div id&#x3D;&quot;outer&quot;&gt; 下的節點 outerDiv.innerHTML &#x3D; &#39;&#39;; &#x2F;&#x2F; 因為清空了&lt;div id&#x3D;&quot;outer&quot;&gt; 下的節點，所以只剩下 outer console.log(allDivs.length); &#x2F;&#x2F; 1&lt;&#x2F;script&gt; 如果改成 document.querySelector 的寫法： 1234567891011121314151617181920&lt;div id&#x3D;&quot;outer&quot;&gt; &lt;div id&#x3D;&quot;inner&quot;&gt;inner&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt; &#x2F;&#x2F; &lt;div id&#x3D;&quot;outer&quot;&gt; var outerDiv &#x3D; document.getElementById(&#39;outer&#39;); &#x2F;&#x2F; 所有的 &lt;div&gt; 標籤 var allDivs &#x3D; document.querySelectorAll(&#39;div&#39;); console.log(allDivs.length); &#x2F;&#x2F; 2 &#x2F;&#x2F; 清空 &lt;div id&#x3D;&quot;outer&quot;&gt; 下的節點 outerDiv.innerHTML &#x3D; &#39;&#39;; &#x2F;&#x2F; document.querySelector 回傳的是靜態的 NodeList，不受 outerDiv 更新影響 console.log(allDivs.length); &#x2F;&#x2F; 2&lt;&#x2F;script&gt; 參考文獻 https://ithelp.ithome.com.tw/articles/10191765 https://www.fooish.com/javascript/dom/ https://www.fooish.com/javascript/dom/traversing.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://cheng-yi-ting.github.io/tags/HTML/"}]},{"title":"JavaScript DOM Node（新增、修改、刪除）","slug":"2019-11-14-JavaScript-11","date":"2019-11-13T16:00:00.000Z","updated":"2019-11-14T13:01:57.235Z","comments":true,"path":"2019/11/14/2019-11-14-JavaScript-11/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/14/2019-11-14-JavaScript-11/","excerpt":"","text":"除了在之前提過的 DOM Node 的類型、以及節點之間的查找與關係。我們在這一篇文章會介紹其他新增、修改和刪除 DOM 節點的方法。 document.createElement(tagName)用來建立一個新的元素。 在建立新的 p 元素 newP 後，這時候我們在瀏覽器上還看不到它，直到透過 appendChild()、insertBefore() 或 replaceChild() 等方法將新元素加入至指定的位置之後才會顯示。 123// 建立一個新的 &lt;p&gt;var newP = document.createElement('p'); 新建立的 newP 我們也可以同時對它指定屬性： 123newP.id = \"myNewP\";newP.className = \"demo\"; document.createTextNode()用來建立文字節點，在 TextNode 被加入至某個節點後，才會顯示。 123456789var newSpan = document.createElement('span');// 建立 textNode 文字節點var textNode = document.createTextNode(\"Hello world!\");// 透過 newSpan.appendChild 將 textNode 加入至 newSpannewSpan.appendChild(textNode); document.createDocumentFragment()它是一種沒有父層節點的「片段文件結構」，透過操作 DocumentFragment 與直接操作 DOM 最關鍵的區別在於 DocumentFragment 不是真實的 DOM 結構，所以 DocumentFragment 的變動並不會影響目前的網頁文件。 我們把可以先建立一個DocumentFragment，把所有的新節點先放到文檔碎片裡面，然後再一次性地添加至 document中，這樣就減少了頁面渲染 DOM 元素的次數。當需要進行大量的 DOM 操作時，使用 DocumentFragment 會比直接操作 DOM 的效能要好。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Click the button to make changes to a list item, using the createDocumentFragment method, then appending the list item as the last child of the list.&lt;&#x2F;p&gt;&lt;ul id&#x3D;&quot;myList&quot;&gt;&lt;li&gt;Coffee&lt;&#x2F;li&gt;&lt;li&gt;Tea&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;script&gt;&#x2F;&#x2F; 取得外層容器 myListvar ul &#x3D; document.getElementById(&quot;myList&quot;);&#x2F;&#x2F; 建立一個 DocumentFragment，可以把它看作一個「虛擬的容器」var fragment &#x3D; document.createDocumentFragment();for (var i &#x3D; 0; i &lt; 3; i++)&#123; &#x2F;&#x2F; 生成新的 li，加入文字後置入 fragment 中。 let li &#x3D; document.createElement(&quot;li&quot;); li.appendChild(document.createTextNode(&quot;Item &quot; + (i+1))); fragment.appendChild(li);&#125;&#x2F;&#x2F; 最後將組合完成的 fragment 放進 ul 容器ul.appendChild(fragment);&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; ParentNode.appendChild(childNode)用來新增一個子節點到指定元素節點的最後面： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div id&#x3D;&quot;name&quot;&gt;&lt;span&gt;hello&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;script&gt; &#x2F;&#x2F; 建立一個新 &lt;div&gt; var newDiv &#x3D; document.createElement(&#39;div&#39;); &#x2F;&#x2F; 建立一個新的文字節點 var newContent &#x3D; document.createTextNode(&#39;I am Cheng-Yi-Ting.&#39;); &#x2F;&#x2F; 將文字節點加到剛建立的 &lt;div&gt; 元素中 newDiv.appendChild(newContent); &#x2F;&#x2F; 取得目前頁面上的 name 元素 var currentDiv &#x3D; document.getElementById(&#39;name&#39;); &#x2F;&#x2F; 將剛建立的 &lt;div&gt; 元素加入 name 元素中 currentDiv.appendChild(newDiv); &#x2F;&#x2F; 顯示 &lt;span&gt;hello&lt;&#x2F;span&gt;&lt;div&gt;I am Cheng-Yi-Ting.&lt;&#x2F;div&gt; alert(currentDiv.innerHTML);&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; ParentNode.insertBefore(newNode, referenceNode)用來將一個新的元素加到某個元素的前面。將新節點 newNode 插入至指定的 referenceNode 節點的前面： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div id&#x3D;&quot;demo&quot;&gt; &lt;span id&#x3D;&quot;s1&quot;&gt;安安&lt;&#x2F;span&gt; &lt;span id&#x3D;&quot;s2&quot;&gt;你好&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;script&gt; &#x2F;&#x2F; 建立一個新的 &lt;span&gt; var newSpan &#x3D; document.createElement(&#39;span&#39;); &#x2F;&#x2F; 增添一些內容 newSpan.innerHTML &#x3D; &#39;Hi&#39;; &#x2F;&#x2F; 取得目前頁面上的 demo 元素 var demo &#x3D; document.getElementById(&#39;demo&#39;); &#x2F;&#x2F; 取得目前頁面上的 s2 元素 var s2 &#x3D; document.getElementById(&#39;s2&#39;); &#x2F;&#x2F; 將新的 span 元素放到 demo 元素中的 s2 子元素前面 demo.insertBefore(newSpan, s2); &#x2F;&#x2F; 顯示 &lt;span id&#x3D;&quot;s1&quot;&gt;安安&lt;&#x2F;span&gt;&lt;span&gt;Hi&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;s2&quot;&gt;你好&lt;&#x2F;span&gt; alert(demo.innerHTML);&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; ParentNode.removeChild(childNode)將指定元素的某個指定的子節點移除： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;!-- Note that the &lt;li&gt; elements inside &lt;ul&gt; are not indented (whitespaces). If they were, the first child node of &lt;ul&gt; would be a text node --&gt;&lt;ul id&#x3D;&quot;myList&quot;&gt; &lt;li&gt;Coffee&lt;&#x2F;li&gt; &lt;li&gt;Tea&lt;&#x2F;li&gt; &lt;li&gt;Milk&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;p&gt;Click the button to remove the first item from the list.&lt;&#x2F;p&gt;&lt;button onclick&#x3D;&quot;myFunction()&quot;&gt;Try it&lt;&#x2F;button&gt;&lt;script&gt;function myFunction() &#123; var list &#x3D; document.getElementById(&quot;myList&quot;); list.removeChild(list.childNodes[0]);&#125;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; ParentNode.replaceChild(newChild, oldChild)用新節點來取代某個子節點，這個新節點可以是某個已存在的節點或是新節點。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;div&gt; &lt;span id&#x3D;&quot;childSpan&quot;&gt;foo bar&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&lt;script&gt;&#x2F;&#x2F; Create an empty element node&#x2F;&#x2F; without an ID, any attributes, or any contentvar sp1 &#x3D; document.createElement(&quot;span&quot;);&#x2F;&#x2F; Give it an id attribute called &#39;newSpan&#39;sp1.id &#x3D; &quot;newSpan&quot;;&#x2F;&#x2F; Create some content for the new element.var sp1_content &#x3D; document.createTextNode(&quot;new replacement span element.&quot;);&#x2F;&#x2F; Apply that content to the new elementsp1.appendChild(sp1_content);&#x2F;&#x2F; Build a reference to the existing node to be replacedvar sp2 &#x3D; document.getElementById(&quot;childSpan&quot;);&#x2F;&#x2F;&lt;span id&#x3D;&quot;childSpan&quot;&gt;foo bar&lt;&#x2F;span&gt;var parentDiv &#x3D; sp2.parentNode;&#x2F;&#x2F; Replace existing node sp2 with the new span element sp1parentDiv.replaceChild(sp1, sp2);&#x2F;&#x2F; Result:&#x2F;&#x2F; &lt;div&gt;&#x2F;&#x2F; &lt;span id&#x3D;&quot;newSpan&quot;&gt;new replacement span element.&lt;&#x2F;span&gt;&#x2F;&#x2F; &lt;&#x2F;div&gt; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; document.write(html)document 物件要將某內容寫入網頁可以用 write() 方法，當瀏覽器讀取頁面，解析到 document.write() 的時候就會停下來，並且將 HTML 內容輸出。 1234567891011&lt;html&gt;&lt;head&gt; &lt;title&gt;document.write example&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;p&gt;first paragraph&lt;&#x2F;p&gt; &lt;script&gt; document.write(&#39;&lt;p&gt;second paragraph&lt;&#x2F;p&gt;&#39;); &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 如果你在頁面載入後，才執行 document.write 則會將裡面的內容完全覆蓋目前的畫面，現在實務上也比較少在使用 document.write。 123window.onload &#x3D; function()&#123; document.write(&quot;Hello world!&quot;);&#125;; 參考文獻 https://ithelp.ithome.com.tw/articles/10191867 https://www.fooish.com/javascript/dom/manipulating.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://cheng-yi-ting.github.io/tags/HTML/"}]},{"title":"BOM 和 DOM !?","slug":"2019-11-12-JavaScript-08","date":"2019-11-12T16:00:00.000Z","updated":"2019-11-15T08:24:38.994Z","comments":true,"path":"2019/11/13/2019-11-12-JavaScript-08/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/13/2019-11-12-JavaScript-08/","excerpt":"","text":"BOM 是什麼?BOM (Browser Object Model，瀏覽器物件模型)，是瀏覽器所有功能的核心，與網頁的內容無關。 BOM 也有人非正式地稱它為 「Level 0 DOM」。 因為它在 DOM level 1 標準前就已存在，而不是真的有文件去規範這些，所以「Level 0 DOM」與「BOM」兩者實際上指的是同一個東西。 window| |navigator |location |frames |screen |history |document |forms |links |anchors |images |all |cookie windowwindow 物件代表瀏覽器視窗本身，擁有一些控制視窗的方法，其中像是 open()、close()、alert()、prompt()、confirm()、setTimeout()等函式，都是以 window 作為名稱空間物件的函式。 你可以在 W3schools 查詢關於 window 函式或方法的使用方式，在使用 window 物件時，可省略 window 關鍵字，直接使用該函式或方法即可。 開啟一個新視窗： 1window.open(\"https://www.w3schools.com\"); 開啟一個確認視窗： 1confirm(\"Press a button!\"); 點擊按紐後，等待三秒鐘，開啟一個警告視窗： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Click the first button to alert \"Hello\" after waiting 3 seconds.&lt;/p&gt;&lt;button onclick=\"myFunction()\"&gt;Try it&lt;/button&gt;&lt;script&gt;var myVar;function myFunction() &#123; myVar = setTimeout(function()&#123; alert(\"Hello\"); &#125;, 3000);&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; window.navigatornavigator 物件主要是包含了瀏覽器的資訊，像是取得瀏覽器的版本、語言以及是否啟用 cookie 等資訊，你可以在 W3schools 查詢這個物件上有哪些資訊可以取得。 123456789101112131415161718&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;div id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;div&gt; &lt;script&gt; var txt &#x3D; &quot;&quot;; txt +&#x3D; &quot;&lt;p&gt;Browser CodeName: &quot; + navigator.appCodeName + &quot;&lt;&#x2F;p&gt;&quot;; txt +&#x3D; &quot;&lt;p&gt;Browser Name: &quot; + navigator.appName + &quot;&lt;&#x2F;p&gt;&quot;; txt +&#x3D; &quot;&lt;p&gt;Browser Version: &quot; + navigator.appVersion + &quot;&lt;&#x2F;p&gt;&quot;; txt +&#x3D; &quot;&lt;p&gt;Cookies Enabled: &quot; + navigator.cookieEnabled + &quot;&lt;&#x2F;p&gt;&quot;; txt +&#x3D; &quot;&lt;p&gt;Browser Language: &quot; + navigator.language + &quot;&lt;&#x2F;p&gt;&quot;; txt +&#x3D; &quot;&lt;p&gt;Browser Online: &quot; + navigator.onLine + &quot;&lt;&#x2F;p&gt;&quot;; txt +&#x3D; &quot;&lt;p&gt;Platform: &quot; + navigator.platform + &quot;&lt;&#x2F;p&gt;&quot;; txt +&#x3D; &quot;&lt;p&gt;User-agent header: &quot; + navigator.userAgent + &quot;&lt;&#x2F;p&gt;&quot;; document.getElementById(&quot;demo&quot;).innerHTML &#x3D; txt; &lt;&#x2F;script&gt; &lt;&#x2F;body&gt; &lt;&#x2F;html&gt; 輸出結果： 12345678910111213141516Browser CodeName: MozillaBrowser Name: NetscapeBrowser Version: 5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36Cookies Enabled: trueBrowser Language: zh-TWBrowser Online: truePlatform: Win32User-agent header: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;78.0.3904.70 Safari&#x2F;537.36 window.locationlocation 物件可以取得瀏覽器目前頁面的URL資訊，也有 reload() 與 replace() 方法，可以重新載入頁面或取代頁面。，你可以在W3schools查詢這個物件上有哪些資訊可以取得。 取代目前頁面的URL： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;button onclick=\"myFunction()\"&gt;Replace document&lt;/button&gt;&lt;script&gt;function myFunction() &#123; location.replace(\"https://cheng-yi-ting.github.io/\") // 取代目前的頁面為此URL&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 取得目前URL所採用的協定： 1location.protocol; // https window.framesframes 物件可以取得瀏覽器中擁有的框架資訊，索引位置是框架在視窗中出現的順序，如果框架有設定id或name屬性，也可以使用[]搭配名稱來取得框架。 點擊按紐後，更改第一個 iframe 的來源： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;Click the button to change the location of the first iframe element (index 0).&lt;/p&gt; &lt;button onclick=\"myFunction()\"&gt;Try it&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;iframe src=\"https://zh.wikipedia.org/wiki/Wiki\"&gt;&lt;/iframe&gt; &lt;iframe src=\"https://www.ettoday.net/\"&gt;&lt;/iframe&gt; &lt;script&gt; function myFunction() &#123; window.frames[0].location = \"https://cheng-yi-ting.github.io/\"; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 點擊按鈕後，修改視窗內所有 iframe 來源URL： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;Click the button to loop through the frames on this page, and change the location of every frame to \"w3schools.com\". &lt;/p&gt; &lt;button onclick=\"myFunction()\"&gt;Try it&lt;/button&gt; &lt;br&gt;&lt;br&gt; &lt;iframe src=\"https://zh.wikipedia.org/wiki/Wiki\"&gt;&lt;/iframe&gt; &lt;iframe src=\"https://www.ettoday.net/\"&gt;&lt;/iframe&gt; &lt;iframe src=\"https://tw.appledaily.com/new/realtime\"&gt;&lt;/iframe&gt; &lt;script&gt; function myFunction() &#123; var frames = window.frames; var i; for (i = 0; i &lt; frames.length; i++) &#123; frames[i].location = \"https://cheng-yi-ting.github.io/\"; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; window.screenscreen 物件可以取得目前視窗的螢幕資訊，像是寬、高、顏色深度等，你可以在W3schools查詢這個物件上有哪些資訊可以取得。 點擊按紐後，顯示視窗寬度： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Click the button to display the available width of your screen.&lt;/p&gt;&lt;button onclick=\"myFunction()\"&gt;Try it&lt;/button&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; var x = \"Available Width: \" + screen.availWidth + \"px\"; document.getElementById(\"demo\").innerHTML = x;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; window.historyhistory 物件可以取得瀏覽器瀏覽歷史，基於安全與隱私，你無法取得瀏覽歷史，但可以有back()、forward()、go()等方法，指定前進、後退至哪個歷史頁面，像是回到上一面、下一頁的功能。你可以在W3schools查詢這個物件上有哪些資訊可以取得。 點擊按紐後，回到上一頁的URL： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;button onclick=\"goBack()\"&gt;Go Back&lt;/button&gt;&lt;p&gt;Notice that clicking on the Back button here will not result in any action, because there is no previous URL in the history list.&lt;/p&gt;&lt;script&gt;function goBack() &#123; window.history.back();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; window.documentDOM (Document Object Model，文件物件模型)，是一個將 HTML 文件以樹狀的結構來表示的模型，而組合起來的樹狀圖，我們稱之為「DOM Tree」。。 舉個來說，如果有個網頁如下： 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;網站標題&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;這是一個內文標題&lt;&#x2F;h1&gt; &lt;p&gt;這是一個段落&lt;&#x2F;p&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; DOM API 就是定義了讓 JavaScript 可以存取、改變 HTML 架構、樣式和內容的方法，甚至是對節點綁定的事件。 JavaScript 就是透過 DOM 提供的 API 來對 HTML 做存取與操作。 參考文獻 https://openhome.cc/Gossip/JavaScript/Level0DOM.html https://ithelp.ithome.com.tw/articles/10191666","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://cheng-yi-ting.github.io/tags/HTML/"}]},{"title":"script tag 的 async 和 defer 屬性","slug":"2019-11-13-JavaScript-09","date":"2019-11-12T16:00:00.000Z","updated":"2020-01-10T15:40:54.947Z","comments":true,"path":"2019/11/13/2019-11-13-JavaScript-09/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/13/2019-11-13-JavaScript-09/","excerpt":"","text":"script標籤針對 &lt;script&gt; 標籤放哪裡，一般會有兩種版本： 放在 &lt;head&gt; ... &lt;/head&gt; 之間 放在 &lt;/body&gt; 之前 把&lt;script&gt; 標籤放在 &lt;/body&gt; 之前，網頁可以正常運作： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1 id&#x3D;&quot;title&quot;&gt;&lt;&#x2F;h1&gt; &lt;script&gt; document.querySelector(&#39;#title&#39;).textContent &#x3D; &quot;這是標題&quot; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 接著，我們試著把 &lt;script&gt; 標籤移到 &lt;head&gt; ... &lt;/head&gt; 之間，這時候會發現網頁一片空白： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;script&gt; document.querySelector(&#39;#title&#39;).textContent &#x3D; &quot;這是標題&quot; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;h1 id&#x3D;&quot;title&quot;&gt;&lt;&#x2F;h1&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 圖片來源：Asynchronous vs Deferred JavaScript 瀏覽器解析 HTML 是一行一行依序向下讀取，在傳統的寫法中，當瀏覽器讀到 &lt;script&gt; 時，便會 暫停解析 DOM，立刻開始下載 &lt;script&gt; 的資源，並在下載完成後立刻執行。由於這樣的特性，便可能造成在 DOM 樹建構不完全時就執行 JavaScript，其中需要操作 DOM 的程式可能就因此無法正確運作，許多衍伸的問題也就因此產生；若是透過 src 外聯 .js 檔案，瀏覽器會「同步地」下載 .js 檔案，在下載完成並執行完程式碼之前，後續的其他資源下載、頁面剖析等，都會被阻斷。執行過程中，使用者便會卡在白畫面，並產生覺得網站太慢、使用者體驗不好等感受。 不過，文件資源的完整載入，是指 HTML 、 CSS 、圖片等都載入完成，而不單指 DOM樹 建立完成；若想在文件剖析完成、 DOM樹 生成時就執行程式碼，建議是將 script 放在文件尾端，通常是 body 標籤之前，因為此時 DOM樹 已經建立，操作 DOM 節點就不是問題了。但在更複雜的網站中，HTML、JavaScript 的檔案都來越大，下載、執行時間也越來越長，需要等到整個 DOM 樹都載入完成才開始下載 &lt;script&gt; 內的資源，從網站讀取完成到可操作之間便會有明顯的延遲感。 這樣的問題該怎麼解決呢？async &amp; defer從 HTML4 開始，&lt;script&gt; 便多了 defer 屬性，HTML5 則多了 async，兩者皆是用來幫助開發者控制 &lt;script&gt; 內資源的載入及執行順序，以及避免 DOM 的解析被資源下載卡住。這兩個屬性只適用在外部引入的檔案，對內嵌程式碼的script標籤沒有影響。 deferdefer 意旨為 延遲（Deferred），也就是說，加上 defer 屬性後，瀏覽器會繼續解析、渲染畫面，而不會因為需要載入 &lt;script&gt; 內的資源而卡在那邊等；如果有多個設置 defer 的 js 標籤存在，則會由上到下依照擺放順序觸發。實際上的執行時間，會在 DOM渲染完畢後，DOMContentLoaded 事件執行之前。 1&lt;script defer src=\"script.js\"&gt;/script&gt; 圖片來源：Asynchronous vs Deferred JavaScript defer 屬性告訴瀏覽器在 HTML 還在解析時加載 js，但是等到 HTML 整個解析完才執行 js。 asyncasync 即為 非同步（Asynchronous），在 &lt;script&gt; 加上 async 屬性後，與 defer 相同的是會在背景執行下載，但不同的是當下載完成會馬上暫停 DOM 解析（若尚未解析完的話），並開始執行 JavaScript。也因為下載完成後會立即執行，如果有多個 async 屬性的 js ，先下載完的就會先執行，因為下載完成的順序是無法預測的，因此「執行順序也就無法預測」。 1&lt;script async src&#x3D;&quot;script.js&quot;&gt;&lt;&#x2F;script&gt; 圖片來源：Asynchronous vs Deferred JavaScript async 屬性告訴瀏覽器可以異步執行(executed asynchronously)，在 HTML 還在解析時加載 js ，當 js 完全下載後才暫停解析 HTML ，執行 js 。 type=”module”在主流的現代瀏覽器中，&lt;script&gt; 的屬性可以加上 type=&quot;module&quot;。這時，瀏覽器會將此檔案認為是一個 JavaScript 模組，其中的解析規則、執行環境會略有不同；這時候的 &lt;script&gt; 預設行為會像是 defer 一樣，背景下載，且等待 DOM 解析、渲染完成後才執行，也因此 defer 屬性無法在 type=&quot;module&quot; 產生作用。但同樣可以透過 async 屬性讓它在下載完成後即刻執行。 使用場景前面已經針對這兩個屬性進行說明了，那麼該如何正確地使用呢？ defer 由於背景載入、不打斷渲染及確保執行順序的特色，基本上沒特別需求的話，建議設定在 &lt;script&gt; ；當然，&lt;script&gt; 本身的擺放順序還是要稍微留心注意。async 比較特別，因為下載後會立刻執行，且不保證順序，一般常見的應用是設定在完全獨立的小模組，例如 背景 Log、頁面廣告等等，在避免造成使用者體驗變差的同時，盡量提早開始產生效果。 async 及 defer 是專屬於 &lt;script&gt; 的屬性，而網頁中的其他資源，我們可以透過 &lt;link&gt; 的 preload、prefetch 屬性，來幫我們 延遲載入 未來才需要用到的資源，詳細的請參考 Preload vs Prefetch。 參考文獻 https://bitsofco.de/async-vs-defer/ https://ithelp.ithome.com.tw/articles/10216858?source=post_page—–8205fddbbafc———————- https://ithelp.ithome.com.tw/articles/10208563 https://ithome.com.tw/voice/132470 https://www.cnblogs.com/jiasm/p/7683930.html https://kknews.cc/code/4eoxg4v.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 邏輯運算子","slug":"2019-11-12-JavaScript-05","date":"2019-11-11T16:00:00.000Z","updated":"2019-11-13T17:12:12.047Z","comments":true,"path":"2019/11/12/2019-11-12-JavaScript-05/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/12/2019-11-12-JavaScript-05/","excerpt":"","text":"邏輯運算子 (Logical Operators)邏輯運算子用來做布林值 (boolean) 的運算，運算結果傳回 true 或 false。 運算子 語法 說明 &amp;&amp; a &amp;&amp; b 如果 a 和 b 都是 true，就會傳回 true， 否則傳回 false || a || b 如果 a 或 b 是 true，就會傳回 true，否則傳回 false ! ! a 如果 a 是 true，就傳回 false，否則傳回 true 在真假判斷式中，所有東西都可以轉換為布林值，而除了以下運算元可以被轉換為 false，其他的值都是 true。 Undefined Null +0, -0, or NaN 空字串 &quot;&quot; 或 &#39;&#39; 12345Boolean(false) // falseBoolean(\"false\") // trueBoolean(\"0\") // trueBoolean(\"\") // falseBoolean(\"''\") // true 但 &amp;&amp; 和 || 還有比較特別的地方，如果運算元的值不是布林值，實際上會傳回其中一個運算元的值。 運算子 語法 說明 &amp;&amp; a &amp;&amp; b 假如 a 可以被轉換成 true 的話，則回傳第二個數值，否則回傳第一個數值。 || a || b 假如 a 可以被轉換成 true 的話，則回傳第一個數值，否則回傳第二個數值。 範例 Logical AND (&amp;&amp;)123456789a1 = true &amp;&amp; true // t &amp;&amp; t returns truea2 = true &amp;&amp; false // t &amp;&amp; f returns falsea3 = false &amp;&amp; true // f &amp;&amp; t returns falsea4 = false &amp;&amp; (3 == 4) // f &amp;&amp; f returns falsea5 = 'Cat' &amp;&amp; 'Dog' // t &amp;&amp; t returns \"Dog\"a6 = false &amp;&amp; 'Cat' // f &amp;&amp; t returns falsea7 = 'Cat' &amp;&amp; false // t &amp;&amp; f returns falsea8 = '' &amp;&amp; false // f &amp;&amp; f returns \"\"a9 = false &amp;&amp; '' // f &amp;&amp; f returns false Logical OR (||)12345678910o1 = true || true // t || t returns trueo2 = false || true // f || t returns trueo3 = true || false // t || f returns trueo4 = false || (3 == 4) // f || f returns falseo5 = 'Cat' || 'Dog' // t || t returns \"Cat\"o6 = false || 'Cat' // f || t returns \"Cat\"o7 = 'Cat' || false // t || f returns \"Cat\"o8 = '' || false // f || f returns falseo9 = false || '' // f || f returns \"\"o10 = false || varObject // f || object returns varObject Logical NOT (!)1234n1 = !true // !t returns falsen2 = !false // !f returns truen3 = !'' // !f returns truen4 = !'Cat' // !t returns false Double NOT (!!)123456n1 = !!true // !!truthy returns truen2 = !!&#123;&#125; // !!truthy returns true: any object is truthy...n3 = !!(new Boolean(false)) // ...even Boolean objects with a false .valueOf()!n4 = !!false // !!falsy returns falsen5 = !!\"\" // !!falsy returns falsen6 = !!Boolean(false) // !!falsy returns false 參考文獻 https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_operators https://ithelp.ithome.com.tw/articles/10191343 https://www.fooish.com/javascript/operator.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 函式（Function）","slug":"2019-11-12-JavaScript-06","date":"2019-11-11T16:00:00.000Z","updated":"2019-11-13T17:11:45.263Z","comments":true,"path":"2019/11/12/2019-11-12-JavaScript-06/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/12/2019-11-12-JavaScript-06/","excerpt":"","text":"JavaScript 中函式是一種物件。 「函式」指的是將一或多段程式指令包裝起來，可以重複使用，也方便維護。 宣告函式的方法有好幾種，但不管是什麼方式，通常一個函式會包含三個部分： 函式的名稱（也可能沒有名稱，稍後會提到） 在括號 ( ) 中的部分，稱為「參數 (arguments) 」，參數與參數之間會用逗號 , 隔開 在大括號 { } 內的部分，內含需要重複執行的內容，是函式功能的主要區塊。 定義函式的方式常見定義函式的方式有這幾種： 函式宣告（Function Declaration） 函式運算式（Function Expressions） 函式關鍵字（Function Keyword） 函式宣告（Function Declaration）「函式宣告」應該是屬於最常見的用法： 1234function 名稱([參數]) &#123; // 函數內容 ...&#125; 範例： 123function fn(number) &#123; return number * number;&#125; 函式運算式（Function Expressions）將一個函式透過 = 指定給某個變數，以下範例為匿名函式(不具名字的函式)： 1234var fn = function (number) &#123; return number * number;&#125;; 也可以賦予函式名稱： 1234var fn = function func(number) &#123; return number * number;&#125;; 請注意，這個名字只在「自己函式的區塊內」有效，脫離函式自身區塊後，變數 func 就不存在了： 123456var fn = function func(number) &#123; console.log( typeof func ); // \"function\" return number * number;&#125;;console.log( typeof func ); // undefined 函式關鍵字（Function Keyword）使用 Function ( F 大寫) 這個關鍵字來建立函式物件。 使用時將參數與函式的內容依序傳入 Function，就可以建立一個函式物件了： 1var fn = new Function('number', 'return number * number'); 透過 new Function 所建立的函式物件，每次執行時都會進行解析「字串」(如 &#39;return number * number&#39; ) 的動作，運作效能較差，所以通常實務上也較少會這樣做。 但不管是透過哪一種方式定義函式，呼叫函式的話就直接用「函式名稱(參數)」的方式，像 fn(5); 就可以了。 參考文獻 [https://ithelp.ithome.com.tw/articles/10191549 https://blog.gtwang.org/programming/defining-javascript-functions/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 提升（Hoisting）","slug":"2019-11-12-JavaScript-07","date":"2019-11-11T16:00:00.000Z","updated":"2019-11-13T17:11:33.511Z","comments":true,"path":"2019/11/12/2019-11-12-JavaScript-07/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/12/2019-11-12-JavaScript-07/","excerpt":"","text":"在瞭解提升（Hoisting）之前，先讓我們看看 JavaScript 中變數的有效範圍(Scope)。 變數的有效範圍 (Scope)在 ES6 之前，JavaScript 變數有效範圍的最小單位是以 function 做分界的。 1234567891011var x = 1;var fn = function(y) &#123; var x = 100; return x + y;&#125;;console.log(fn(50)); // 150console.log(x); // 1 由於函式 fn() 裡面再次定義了變數 x，所以當我們執行 fn(50) 時，會將 50 作為參數傳入 fn() 的 y，那麼 return x + y 的結果自然就是 100 + 50 的 150 了。 因為「切分變數有效範圍的最小單位是 “function” 」，所以在函式區塊內透過 var 定義的 x 實際上只屬於這個函式。 換句話說，外面的 x 跟 function 內的 x 其實是兩個不同的變數，所以最後一行印出的 x 是 1 而不是 100 。 如果 function 內部沒有 var x 呢？如果自己的 function 內如果找不到，就會一層層往外找，直到全域變數為止： 範例： 123456789var x = 1;var fn = function(y) &#123; // 內部找不到 x 就會到外面找，直到全域變數為止。 // 都沒有就會報錯：ReferenceError: x is not defined return x + y;&#125;;console.log(fn(50)); // 51 要注意的是， function 可以讀取外層已經宣告的變數， 但外層拿不到裡面宣告的變數。 沒有 var 宣告的變數會變成全域變數1234567891011var x = 1;var fn = function(y) &#123; x = 100; return x + y;&#125;;console.log(fn(50)); // 150console.log(x); // 100 由於在 function 內沒有重新宣告 x 變數，使得 x = 100 跑去變更了外層的同名變數 x。 提升 (Hoisting)一般在寫程式的時候，我們都會定義好變數，然後才去使用它，如果在尚未定義的情況下，直接去使用這個變項，通常都會出現錯誤訊息！ 然而，在 javascript 中有一個蠻特別的概念是 hoisting ，指的是在 JavaScript 中，它會把定義的變數移到最前面先執行。 JavaScript 僅提升宣告的部分，而不是初始化。如果在使用該變數後才宣告和初始化，那麼該值將是 undefined。 12345678910111213var x = 1;var fn = function(y) &#123; console.log(x); // undefined var x = 100; return x + y;&#125;;console.log(fn(50)); // 150console.log(x); // 1 上面的例子，實際上在瀏覽器 (或者編譯器) 的眼中，是長這樣的： 1234567891011121314var x = 1;var fn = function(y) &#123; var x; console.log(x); // undefined x = 100; return x + y;&#125;;console.log(fn(50)); // 150console.log(x); // 1 除了變數以外，函式也有提升。透過「函式宣告」方式定義的函式可以在宣告前使用 (函式提升) ： 1234567fn(2); // 4function fn(number) &#123; return number * number;&#125; 而透過「函式運算式」定義的函式則是會出現錯誤： 1234567fn(2); // TypeError: square is not a functionvar fn = function (number) &#123; return number * number;&#125;; 與變數提升的差別在於變數提升只有宣告被提升，而函式的提升則是包括內容完全被提升。 參考文獻 https://ithelp.ithome.com.tw/articles/10191549 https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting https://pjchender.blogspot.com/2015/12/javascript-hoisting.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 中的「傳值」 與 「傳址」","slug":"2019-11-10-JavaScript-04","date":"2019-11-10T16:00:00.000Z","updated":"2019-11-13T17:12:32.047Z","comments":true,"path":"2019/11/11/2019-11-10-JavaScript-04/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/11/2019-11-10-JavaScript-04/","excerpt":"","text":"基本型別假設我們有兩個變數a和b分別設定為 10，接著把b的值等於a；最後再把a的值改為20。 123456789var a = 10;var b = 10;//在基本型別的時候，會認為這兩個變數的「值」是相等的，因為兩個變數的數值都是 10console.log( a === b ); // truea=20;var c=a;console.log(\"a is \"+a); // a is 20console.log(\"b is \"+b); // b is 10console.log(\"c is \"+c); // c is 10 變數 c 的值是透過複製變數 a 的值而來。 但變數 a 更新之後，不會去影響變數 c 的數值。 表面上看起來變數 c 的內容是透過複製變數 a 而來，但此時若變數 a 的內容為基本型別時，實際上變數 c 是去建立了一個新的值，然後將變數 a 的內容複製了一份過來。 Call By Value當我們在建立「基本型別」 的變數時，根據上面的例子，a 會存在記憶體中的某個位置。這時候，當我指定另一個變數 c，它的值等同於 a 的時候，c 實際上會建立另一個獨立的記憶體位置，接著再把 a 的值存在這個獨立的記憶體位置。也就是說， a 和 b 其實是存在於兩個不同的記憶體位置，因此彼此並不會乎相干擾影響，這種情況，我們就稱為 Call By Value 。 物件型別JavaScript 的物件都應該看作是一個「實體」。 1234567891011var a= &#123; value: 10 &#125;;var b= &#123; value: 10 &#125;;//// a 與 b 不是同一個實體。console.log( a === b ); // falseb=a;a.value=20;console.log(a.value); // 20console.log(b.value); // 20console.log( a === b ); // true 「物件」在 JavaScript 中是透過「引用」的方式傳遞資料的，當 a.value 的內容被更新了之後，連帶著 b.value 也跟著改變。 Call By Reference當我將變數 a 設立成一個 Object 時，一樣會存在記憶體中的某個位置；但是當我建立一個變數 b，並且把變數 b 的值等同於 a 時，這時候並不會再給予它一個新的位置，而是將 b 指定到物件 a 的位置，讓變數 a 和 b 使用相同的記憶體位置，因此，當 a 的值改變的時候 b 的值也會改變，這種情形我們就稱為 Call By Reference。 例外情況如果使用 object literal 的方式指定物件的值，那麼就會是 Call by value： 123456789var a= &#123; value: 10 &#125;;var b;b=a;a=&#123;value: 20&#125;;console.log(a); // console.log(b); // 在這種情況下，因為它並不清楚 a 的內容是已經存在的，所以會建立一個新的記憶體位置來存放 a 物件裡面的內容。 Call by sharingJavaScript 實際上是另一種稱做「call by sharing」的模式，其特點在於，當 function 的參數，如 function changeValue(obj){ ... } 中的 obj 被重新賦值的時候，外部變數的內容是不會被影響的。 1234567891011var a= &#123; value: 10 &#125;;function changeValue(obj) &#123; obj = &#123; value: 20 &#125;;&#125;changeValue(a);console.log(a); // 此時 a仍是 &#123; value: 10 &#125; 如果不是重新賦值的情況，則又會回到傳址的方式： 123456789101112var a = &#123; value: 10 &#125;;function changeValue(obj) &#123; // 僅更新 obj.value，並未重新賦值 obj.value = 20;&#125;changeValue(a);console.log(a); // 此時 a 則會變成 &#123; value: 20 &#125; 參考文獻 https://ithelp.ithome.com.tw/articles/10191057 https://pjchender.blogspot.com/2016/03/javascriptby-referenceby-value.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 陣列","slug":"2019-11-11-JavaScript-03","date":"2019-11-09T16:00:00.000Z","updated":"2019-11-13T17:12:46.791Z","comments":true,"path":"2019/11/10/2019-11-11-JavaScript-03/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/10/2019-11-11-JavaScript-03/","excerpt":"","text":"陣列JavaScript 的陣列可以看作是一種特別的「物件」， 陣列內可以是原始的資料類型、其他陣列、函式等等。 建立陣列陣列可以使用字面表達語法來建立︰ 1var fruits = ['Apple', 'Banana']; 或是使用 Array 的建構子來建立︰ 123var fruits = new Array();fruits[0] = \"Apple\";fruits[1] = \"Banana\"; （透過索引）取得陣列項目12var first = fruits[0]; //Applevar last = fruits[fruits.length - 1]; // Banana 迭代陣列12345fruits.forEach(function(item, index, array) &#123; console.log(item, index);&#125;);// Apple 0// Banana 1 加入項目至陣列末端12var newLength = fruits.push('Orange');// [\"Apple\", \"Banana\", \"Orange\"] 移除陣列末端項目12var last = fruits.pop(); // 移除 (最末端的) Orange// [\"Apple\", \"Banana\"]; 移除陣列前端項目12var first = fruits.shift(); // 移除 (最前端的) Apple// [\"Banana\"]; 加入項目至陣列前端12var newLength = fruits.unshift('Strawberry') // 加到陣列前端// [\"Strawberry\", \"Banana\"]; 在陣列中尋找項目的索引12345fruits.push('Mango');// [\"Strawberry\", \"Banana\", \"Mango\"]var pos = fruits.indexOf('Banana');// 1 移除指定索引位置的項目123var removedItem = fruits.splice(pos, 1); // 移除 pos 起的 1 個項目// [\"Strawberry\", \"Mango\"] 移除指定索引位置起的多個項目123456789101112131415var vegetables = ['Cabbage', 'Turnip', 'Radish', 'Carrot'];console.log(vegetables); // [\"Cabbage\", \"Turnip\", \"Radish\", \"Carrot\"]var pos = 1, n = 2;var removedItems = vegetables.splice(pos, n); // 這就是移除項目的方式，// n 表示從該位置 (pos) 開始，一直到陣列的尾端有多少項目需要移除console.log(vegetables); // [\"Cabbage\", \"Carrot\"] (原始的陣列被改變)console.log(removedItems); // [\"Turnip\", \"Radish\"] 複製陣列12var shallowCopy = fruits.slice(); // 這就是複製陣列的方式// [\"Strawberry\", \"Mango\"] 將陣列元素合併成字串12345678910var elements = ['Fire', 'Air', 'Water'];console.log(elements.join());// expected output: \"Fire,Air,Water\"console.log(elements.join(''));// expected output: \"FireAirWater\"console.log(elements.join('-'));// expected output: \"Fire-Air-Water\" 刪除陣列元素刪除陣列元素後，該元素為undefined。 1234var arr = [1, 2, 3, 4, 5, 6];delete arr[1];//[1,undefined,3, 4, 5, 6] 將字串或輸入參數組成陣列12345console.log(Array.from('foo'));// expected output: Array [\"f\", \"o\", \"o\"]console.log(Array.from([1, 2, 3], x =&gt; x + x));// expected output: Array [2, 4, 6] 對陣列中的各元素進行操作，操作後的值會被寫入新的陣列中並返回map 會將所有陣列中的元素依序分別傳入一次至 callback 函式當中，並以此回呼函式每一次被呼叫的回傳值來建構一個新的陣列。 12345678910111213141516171819var array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]var arr = [1, 2, 3, 4, 5, 6];var arr2 = arr.map(function (element,index,array) &#123; return element * 2;&#125;);console.log(arr2);// [2, 4, 6, 8, 10, 12] 會將兩個陣列合併產生新的陣列，原陣列不改變concat() 方法被用來合併兩個或多個陣列。此方法不會改變現有的陣列。 12345const array1 = ['a', 'b', 'c'];const array2 = ['d', 'e', 'f'];console.log(array1.concat(array2));// expected output: Array [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] 陣列比對（some）陣列比對，只要有一個元素是 true，就返回 true。 123456789var array = [1, 2, 3, 4, 5];var even = function(element) &#123; // checks whether an element is even return element % 2 === 0;&#125;;console.log(array.some(even));// expected output: true 陣列比對（every）陣列比對，所有元素都是 true 才是 true。 12345678function isBelowThreshold(currentValue) &#123; return currentValue &lt; 40;&#125;var array1 = [1, 30, 39, 29, 10, 13];console.log(array1.every(isBelowThreshold));// expected output: true 陣列過濾陣列過濾，透過 filter 的過濾條件返回一個新陣列。 123456var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [\"exuberant\", \"destruction\", \"present\"] 檢查傳入的值是否為陣列12345678910111213141516171819// 下方都回傳 trueArray.isArray([]);Array.isArray([1]);Array.isArray(new Array());Array.isArray(new Array('a', 'b', 'c', 'd'));Array.isArray(new Array(3));// 小細節：Array.prototype 本身是陣列：Array.isArray(Array.prototype);// 下方都回傳 falseArray.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(17);Array.isArray('Array');Array.isArray(true);Array.isArray(false);Array.isArray(&#123; __proto__: Array.prototype &#125;); 參考文獻 https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/map https://sweeteason.pixnet.net/blog/post/41263148-javascript-%E5%B8%B8%E7%94%A8%E7%9A%84%E9%99%A3%E5%88%97%28array%29%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 物件","slug":"2019-11-9-JavaScript-02","date":"2019-11-09T16:00:00.000Z","updated":"2019-11-11T06:19:51.953Z","comments":true,"path":"2019/11/10/2019-11-9-JavaScript-02/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/10/2019-11-9-JavaScript-02/","excerpt":"","text":"物件及屬性所有基本型別 (Primitives) 以外的值都是物件。 一個物件可以是個零至多種屬性的集合，而屬性是鍵 (key) 與值 (value) 之間的關聯。 一個屬性的「值」可以是某個基本型別，也可以是另一個物件，甚至可以是一個函數。 可以透過 new 關鍵字來建立一個物件實體，再替這個物件新增屬性與方法： 例如，我們可以定義一個物件為 myCar ，並賦予三個屬性， make 、 model 和 year 。 1234var myCar = new Object();myCar.make = 'Ford';myCar.model = 'Mustang';myCar.year = 1969; 或是使用大括號 { } 來建立一個物件，並且在建立物件的同時直接指定屬性至該物件內。 這種建立物件的方式稱為「物件實字 (Object literal)」。 12345var myCar = &#123; make : 'Ford', model : 'Mustang', year : 1969&#125;; 屬性存取物件的屬性可以透過 . 來進行存取： 123myCar.make;myCar.model;myCar.year; 或是可以透過 [ ] 來進行存取： 123myCar['make'];myCar['model'];myCar['year']; 存取物件沒有的屬性會顯示 undefined 。 1myCar.color; // undefined 新增 / 更新 屬性新增與更新屬性的語法是一樣的，只需對屬性進行指派值的動作。 123myCar[\"year\"]=1995;myCar[\"color\"]=\"yellow\";myCar.tire=\"EDITION\"; 屬性刪除透過 delete 關鍵字來刪除，刪除後的屬性會變成 undefined： 1234myCar.color=\"red\";myCar.color; //reddelete myCar.color;myCar.color; //undefined 參考文獻 https://ithelp.ithome.com.tw/articles/10190962 https://ithelp.ithome.com.tw/articles/10193605 https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Working_with_Objects","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"JavaScript 變數與資料型別","slug":"2019-11-7-JavaScript-01","date":"2019-11-08T16:00:00.000Z","updated":"2019-11-13T17:11:13.327Z","comments":true,"path":"2019/11/09/2019-11-7-JavaScript-01/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/09/2019-11-7-JavaScript-01/","excerpt":"","text":"變數變數是用來儲存資料和進行運算的基本單位，就像是資料的容器。 例如下面這個例子，x y z 都是所謂的變數： 123var x = 1;var y = 2;var z = x + y; JavaScript 變數的命名有一定規則和限制： 變數的開頭只能是字母、底線_或錢字號$，後面可以是英文字母、底線_ 或是錢字號 $ 以及數字。 大小寫有區別，例如變數 test 不等於變數 Test 變數名稱不可以是保留字，否則會出現 SyntaxError。 1var break = 'test'; Uncaught SyntaxError: Unexpected token 'break' JavaScript 允許的字母還包含 Unicode，所以中文也可以用作變數名稱，例如： 12var 測試 = 'test';console.log(測試); 弱型別相較於Java、C++「強型別」語言，宣告出來的變數無法再被指派為其他型別的值，而JavaScript為「弱型別」語言，其變數擁有以下特性： 變數並沒有綁定任何的型態 變數本身無需宣告型別 宣告後的變數可以被自由指派為其他型別的值 範例1234var test = 'test';console.log(test); //\"test\"test = 100; console.log(test); //100 變數無法被刪除在 JavaScript 中，變數無法被刪除： 1234var test = 'test';console.log(test); //\"test\"delete test; console.log(test); //\"test\" 如果是刪除物件的屬性，則刪除後該屬性為 undefined： 123456789101112var Employee = &#123; firstname: \"John\", lastname: \"Doe\"&#125;console.log(Employee.firstname);// expected output: \"John\"delete Employee.firstname;console.log(Employee.firstname);// expected output: undefined 變數的資料型別變數沒有型別，值才有。 JavaScript 內建的型別主要可以分成基本型別 (Primitives) 與物件型別 (Object) 兩大類： 基本型別： string number boolean null undefined 除了上述幾種之外，都可以歸類至物件型別 (Object)。 判斷型別的方式，可以透過 typeof 運算子。 12345console.log(typeof 'test');// stringconsole.log(typeof 100);// numberconsole.log(typeof true);// booleanconsole.log(typeof window.alert); // 'function'console.log(typeof null); // 'object' 雖然透過 typeof 去檢查一個「函式 (function) 」的時候，會得到 “Function” 的結果，但實際上仍屬於 Object 的一種。 而 typeof null 的結果為 Object 。 stringJavaScript 沒有 char (字元) 的概念，只有字串。字串使用 ‘ ‘ (單引號) 或是 “ “ (雙引號) 將文字放入其中，兩者不可混用，意即用單引號開頭的，就要用單引號收合，反過來說也是。 單引號與雙引號的使用在 JavaScript 沒有什麼差異。 特殊符號的處理要在單引號內包覆單引號，或是雙引號內包覆雙引號就會出現問題： 1var name = \"My name is \"Ray\"\"; Uncaught SyntaxError: Unexpected identifier 可以在符號前加上 \\ (跳脫字元)來解決。 12var name = \"My name is \\\"Ray\\\"\";console.log(name);//My name is \"Ray\" 字串內容斷行多行字串時，可以透過 \\ (反斜線) 來繼續： 1234var test = '這次\\連假\\要出去玩';console.log(test);//這次連假要出去玩 請注意 \\ 反斜線後面不能有任何字元 number整數或帶有小數點的數字都是數值型別另外還有幾種特殊的數字： Infinity (無限大) Infinity (負無限大) NaN (不是數值，Not a Number)。 boolean值只有兩種：true 以及 false，布林值通常用在判斷式，作為控制程式流程的用途。 Nullnull 在 JavaScript 中表示一個空值，變數要經過宣告並賦予 null ，才會形成 null 型態。 1var test = null; undefined變數在初始的時候未給予任何值，宣告 test 時因為沒有賦予任何值所以是 undefined，如果先定義 test 為 100 ; 接著再把 test 設為 undefined，我們會發現 test 又再次變成了undefined了。 1234567var test; console.log(test);//undefinedtest=100;test=undefined;if(test===undefined)&#123; console.log(\"test is undefined.\");&#125; 參考文獻 https://ithelp.ithome.com.tw/articles/10190873","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://cheng-yi-ting.github.io/tags/JavaScript/"}]},{"title":"如何在 Visual Studio Code 撰寫 Markdown","slug":"2019-11-5-Visual-Studio-Code-Markdown","date":"2019-11-05T16:00:00.000Z","updated":"2020-01-10T15:43:39.961Z","comments":true,"path":"2019/11/06/2019-11-5-Visual-Studio-Code-Markdown/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/06/2019-11-5-Visual-Studio-Code-Markdown/","excerpt":"","text":"本篇介紹如何於Visual Studio Code中安裝Markdown插件。 點擊Extension圖示(或是按下ctrl+shift+X) 在搜尋欄位輸入 Markdown 搜尋套件 點擊 install 按鈕安裝 安裝常用的Markdown優化： 很多人用Markdown是為了最後上傳到Github Pages，所以安裝這個套件，就能在本地預覽Markdown文件最終在Github Pages中的渲染樣式。 點擊zh-TW後重啟Visual Studio Code 完成繁體中文語系設定 參考文獻 https://medium.com/mr-brown/ide-visual-studio-code-%E4%B8%AD%E6%96%87%E5%8C%96%E6%95%99%E5%AD%B8-ff0abd789608","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://cheng-yi-ting.github.io/tags/IDE/"},{"name":"VSCode","slug":"VSCode","permalink":"https://cheng-yi-ting.github.io/tags/VSCode/"}]},{"title":"使用 HTML+CSS 製作簡易名片","slug":"2019-11-4-Business-Card","date":"2019-11-04T16:00:00.000Z","updated":"2020-01-10T15:45:43.166Z","comments":true,"path":"2019/11/05/2019-11-4-Business-Card/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/05/2019-11-4-Business-Card/","excerpt":"","text":"程式碼同步於此連結：使用 HTML+CSS 製作簡易名片 使用*{ }選取器取消網頁所有物件的間距為0： 12345* &#123; font-family : 微軟正黑體; margin: 0; padding: 0;&#125; 為了使div元素的height為整個瀏覽器窗口高度，需先將其父元素設定為100%，這樣子元素高度才會起作用，也就是width:100%; height:100%; 1234html,body&#123; width : 100%; height : 100%;&#125; 延伸閱讀：為什麼 height:100% 沒有作用? 設定背景為綠色，頁面最上和最下留30px的黑邊；使用box-sizing屬性來讓元素的內距和邊框不會增加元素本身的寬度： CSS123456body&#123; background-color : #A9CEAE; border-top : solid 30px #3B3E3C; border-bottom : solid 30px #3B3E3C; box-sizing : border-box;&#125; HTML1234&lt;body&gt; &lt;div class=\"mark\"&gt;NEVER&lt;br&gt; &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbspSTOP &lt;/div&gt;&lt;/body&gt; CSS 以下是包含各個元素的CSS設定 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980.mark &#123; font-size: 230px; position: absolute;&#125;.namecard &#123; width: 500px; height: 300px; border-radius: 15px 5px 5px 15px; margin: auto; margin-top: 100px; padding-left: 100px; background-color: #3B3E3C; color: white; letter-spacing: 1px; box-shadow: 25px 25px 15px -20px rgba(0, 0, 0, 0.5); position: relative;&#125;.namecard h2 &#123; font-size: 30px;&#125;.namecard h2 span &#123; font-size: 17px; font-weight: 300;&#125;.namecard h5 &#123; font-size: 15px; letter-spacing: 1px; font-weight: 300;&#125;.namecard p &#123; font-size: 15px; font-weight: 300;&#125;.hr1 &#123; border: 2px solid gray; box-shadow: 0px 2px 5px black;&#125;.gap &#123; width: 35px; height: 240px; right: 540px; top: 30px; position: absolute; background-color: #A9CEAE; border-radius: 15px 0px 0px 15px; box-shadow: inset 25px 20px 20px -20px rgba(0, 0, 0, 0.5);&#125;.vline &#123; position: absolute; height: 299px; right: 520px; border: solid 2px gray;&#125;.screw &#123; border: solid 2px gray; border-radius: 100%; position: absolute; width: 10px; height: 10px; /* background-color : gray; */&#125;.screw1 &#123; right: 500px; top: 15px;&#125;.screw2 &#123; right: 500px; top: 280px;&#125; h5,h2,p CSS設定123456789101112131415161718192021222324252627h5 &#123; display: block; font-size: 0.83em; margin-block-start: 1.67em; margin-block-end: 1.67em; margin-inline-start: 0px; margin-inline-end: 0px; font-weight: bold;&#125;h2 &#123; display: block; font-size: 1.5em; margin-block-start: 0.83em; margin-block-end: 0.83em; margin-inline-start: 0px; margin-inline-end: 0px; font-weight: bold;&#125;p &#123; display: block; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px;&#125; HTML1234567891011121314151617&lt;body&gt; &lt;div class=\"mark\"&gt;NEVER&lt;br&gt; &amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbspSTOP &lt;/div&gt; &lt;div class=\"namecard\"&gt; &lt;div class=\"gap\"&gt;&lt;/div&gt; &lt;div class=\"vline\"&gt;&lt;/div&gt; &lt;div class=\"screw screw1\"&gt;&lt;/div&gt; &lt;div class=\"screw screw2\"&gt;&lt;/div&gt; &lt;/br&gt; &lt;h2&gt;鄭亦渟 &lt;span&gt;Cheng Yi Ting&lt;/span&gt; &lt;/h2&gt; &lt;h5&gt;國立中正大學-資訊工程學系&lt;/h5&gt; &lt;hr class=\"hr1\" /&gt; &lt;p&gt;\"Opportunity seldom knocks twice.\"&lt;br&gt;Love to try anything I haven't experienced.&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://cheng-yi-ting.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://cheng-yi-ting.github.io/tags/CSS/"}]},{"title":"變更 Visual Studio Code 介面語系為中文","slug":"2019-11-5-Visual-Studio-Code-Chinese","date":"2019-11-04T16:00:00.000Z","updated":"2020-01-10T15:44:28.804Z","comments":true,"path":"2019/11/05/2019-11-5-Visual-Studio-Code-Chinese/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/05/2019-11-5-Visual-Studio-Code-Chinese/","excerpt":"","text":"本篇介紹如何修改Visual Studio Code為繁體中文，其他不同語系修改方式皆相同，只要安裝不同語系插件即可。 點擊Extension圖示(或是按下ctrl+shift+X) 在搜尋欄位輸入 Chinese(Traditional)搜尋中文化套件 點擊 install 按鈕安裝 安裝完成後按下快捷鍵ctrl+shift+p開啟搜尋列 輸入Configure Display Language 開啟 locale.json 檔進行設定 把 “locale”:”en” 的 en 改成 zh-TW 後存檔 重啟Visual Studio Code 完成繁體中文語系設定 參考文獻 https://medium.com/mr-brown/ide-visual-studio-code-%E4%B8%AD%E6%96%87%E5%8C%96%E6%95%99%E5%AD%B8-ff0abd789608","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://cheng-yi-ting.github.io/tags/IDE/"},{"name":"VSCode","slug":"VSCode","permalink":"https://cheng-yi-ting.github.io/tags/VSCode/"}]},{"title":"為什麼 height:100 沒有作用?","slug":"2019-11-4-height-100percent","date":"2019-11-03T16:00:00.000Z","updated":"2020-01-10T15:45:02.158Z","comments":true,"path":"2019/11/04/2019-11-4-height-100percent/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/04/2019-11-4-height-100percent/","excerpt":"","text":"設定 height:100% 元素沒反應!?當設計一個頁面的時候，你設置了一個div元素，希望元素能佔滿整個瀏覽器窗口，最自然的做法，你會給這個div添加 width:100px; height:100px; 的css屬性。然後你會發現，這個元素的寬度會擴展到整個瀏覽器窗口，但是高度卻沒有起任何作用，那為什麼height:100%會無法作用呢？ 按照常理推斷，當我們用CSS的height屬性定義一個元素的高度時，這個元素應該要按照設定在瀏覽器的縱向空間裡擴展相應的空間距離，例如：一個div元素的height為100px;，那它應該在頁面的豎向空間裡佔滿100px的高度才對。 根據W3C的規範，百分比的高度在設定時需要根據這個元素的父元素容器的高度。所以，如果你把一個div的高度設定為height:50%;，而它的父元素的高度是100px時，那麼，這個div的高度應該是50px。 瀏覽器寬度和高度瀏覽器在計算寬度時會考慮瀏覽器窗口的打開寬度。如果不給寬度設定任何值，那瀏覽器會自動將頁面內容填滿整個橫向寬度。 但是高度的計算方式完全不一樣。事實上，瀏覽器根本就不計算內容的高度，除非內容超出了視窗範圍(導致滾動條出現)；否則，瀏覽器就會簡單的讓內容往下堆砌，頁面的高度根本就無需考慮。 當你讓一個元素的高度設定為百分比高度時，無法根據獲取父元素的高度，也就無法計算自己的高度，所以瀏覽器不會對這個值有任何的反應。 範例設定元素 width:100px; height:100px; 123456789&lt;!DOCTYPE html&gt;&lt;body&gt; &lt;div style=\"width:100%;height:100%;background-color:green;\"&gt; &lt;p&gt; 元素設定高度為100% &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 現在你給了這個div的高度為100%，它有兩個父元素 &lt;body&gt; 和 &lt;html&gt; ；為了讓div的百分比高度起作用，需要設定這兩個屬性的高度。 123456789&lt;!DOCTYPE html style=\"height:100%\"&gt;&lt;body style=\"height:100%\"&gt; &lt;div style=\"width:100%;height:100%;background-color:green;\"&gt; &lt;p&gt; 元素設定高度為100% &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 從這個範例中你可以發現， height:100%; 生效了 參考文獻 http://www.webhek.com/post/css-100-percent-height.html https://segmentfault.com/a/1190000012707337","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://cheng-yi-ting.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://cheng-yi-ting.github.io/tags/CSS/"}]},{"title":"如何在 Hexo 文章中插入本地圖片","slug":"2019-11-2-Hexo-insert-images","date":"2019-11-02T16:00:00.000Z","updated":"2020-01-10T15:46:15.053Z","comments":true,"path":"2019/11/03/2019-11-2-Hexo-insert-images/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/03/2019-11-2-Hexo-insert-images/","excerpt":"","text":"Hexo文件設定將 Hexo 文件裡面的 _config.yml 的此參數設定為true 1post_asset_folder: true 這個功能目的是在你使用Hexo new 文章名稱，建立一篇新的文章。文章相對路徑為\\source_posts，例如我輸入以下指令： 1Hexo new test 目錄下就會生成一個test.md文件和一個與文章同名的資料夾，可以用來放置該文章相關的所有資源，例如圖片、附件等等。 安裝 hexo-asset-image 套件安裝 hexo-asset-image 圖片路徑轉換套件，使用npm進行安裝： 1npm install https:&#x2F;&#x2F;github.com&#x2F;CodeFalling&#x2F;hexo-asset-image --save 插入圖片1![當圖片無法顯示時出現的文字](圖片檔名.PNG) 也支援使用 HTML 的img標籤，可以更改圖片高度、寬度等設定。 1&lt;img src&#x3D;&quot;xx.png&quot; width &#x3D; &quot;100%&quot; height &#x3D; &quot;100%&quot;&gt; 參考文獻 http://etrd.org/2017/01/23/hexo%E4%B8%AD%E5%AE%8C%E7%BE%8E%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/ https://blog.csdn.net/Sugar_Rainbow/article/details/57415705","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://cheng-yi-ting.github.io/tags/Hexo/"}]},{"title":"Git for Windows","slug":"2019-11-2-Git-for-Windows","date":"2019-11-01T16:00:00.000Z","updated":"2020-01-10T15:48:28.939Z","comments":true,"path":"2019/11/02/2019-11-2-Git-for-Windows/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/02/2019-11-2-Git-for-Windows/","excerpt":"","text":"Git Installation on Windows要在 Windows 作業系統上安裝 Git，請到官方網站下載合適的版本： 網址：https://git-scm.com/download/win 網站會偵測使用者的系統版本為32-bit或64-bit，進行自動下載。 安裝過程中，每個步驟都點選下一步直到安裝完成： 安裝完成後，請搜尋「Git Bash」應用程式： 進入 Git Bash 後，請試試輸入以下兩個指令，來驗證 Git 是否安裝成功，以及查看版本資訊： 若看到類似的訊息，就表示安裝成功。 使用者設定要開始使用 Git，請先對使用者設定識別資料，分別是使用者名稱及電子郵件，每次 Git 提交會使用此資訊，請打開終端機，輸入下面這兩行指令，請自行替換使用者及電子信箱名稱： 12$ git config --global user.name \"Cheng-Yi-Ting\"$ git config --global user.email \"d02405035@ems.npu.edu.tw\" 輸入完成之後，可以再檢視一下目前的設定： 123$ git config --listuser.email=d02405035@ems.npu.edu.twuser.name=Cheng-Yi-Ting 你也可以輸入 git config &lt;key&gt; 來檢視某個設定目前的值： 12git config user.nameCheng-Yi-Ting 專案設定不同的作者若有傳遞 –global 參數，意思是要做全域（Global）的設定，不論 Git 做任何事都會採用此資訊，如果遇到要幫特定的專案設定不同的作者及電子郵件，可以在該專案目錄下進行 Git 設定的時候，加上 –local 參數： 12$ git config --local user.name ray$ git config --local user.email ray@gmail.com","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://cheng-yi-ting.github.io/tags/Git/"}]},{"title":"設定 SSH 連接 GitHub","slug":"2019-11-2-Git-SSH","date":"2019-11-01T16:00:00.000Z","updated":"2020-01-11T02:50:47.484Z","comments":true,"path":"2019/11/02/2019-11-2-Git-SSH/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/02/2019-11-2-Git-SSH/","excerpt":"","text":"關於 SSH keys使用SSH協定，連接到遠端服務器 GitHub 進行身份驗證，透過設定 SSH keys，就不用在每次訪問 GitHub 的時候提供用戶名稱或密碼。 檢查 SSH keys在生成 SSH keys之前，你可以先檢查本機是否有已存在的 SSH keys。 進入 Git Bash 輸入 bash ls -al ~/.ssh 查看是否有存在的 SSH keys 12$ ls -al ~&#x2F;.ssh# Lists the files in your .ssh directory, if they exist&lt;&#x2F;code&gt; 查看目錄中是否已經有 public SSH key 預設情況下，public SSH key 的文件名會是以下類型之一，副檔名為 .pub 就是 public key，另一個則是 private key： id_dsa.pub id_ecdsa.pub id_ed25519.pub id_rsa.pub 如果沒有 .ssh 的目錄，或是沒有 id_xxx 和 id_xxx.pub 來命名的一對 key ，請生成一個新的 SSH keys： 生成新的 SSH keys 進入 Git Bash 複製以下指令，並替換自己的 GitHub 電子郵件 1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 根據提供的電子郵件作為標籤，建立一個新的 SSH key。 1&gt; Generating public&#x2F;private rsa key pair. 接下來的步驟都按 Enter 即可。 增加新的 SSH key 到 Github 複製 SSH key 12$ clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 到 Github 網站加入你的 SSH key 點擊 SSH and GPG keys 點擊 New SSH key 或 Add SSH key. 在”標題”中為新的 key 添加一個描述性的標籤。 例如：如果是你個人的筆電，則可以將此名稱設為”Personal NB”。 貼上第一步驟複製的 key 點擊 Add SSH key 再次輸入密碼確認 參考文獻 https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent http://wiki.csie.ncku.edu.tw/github https://git-scm.com/book/zh-tw/v1/%E4%BC%BA%E6%9C%8D%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://cheng-yi-ting.github.io/tags/Git/"}]},{"title":"撰寫技術 Blog 的優點","slug":"2019-11-1-Star-Blog","date":"2019-10-31T16:00:00.000Z","updated":"2020-01-04T01:33:46.041Z","comments":true,"path":"2019/11/01/2019-11-1-Star-Blog/","link":"","permalink":"https://cheng-yi-ting.github.io/2019/11/01/2019-11-1-Star-Blog/","excerpt":"","text":"前言最近想開始寫Blog，主要是想寫技術文，也是幫助自己熟悉一些技術，簡單整理一下寫Blog的好處： 好處一：歷史筆記許多頻繁接觸的東西，過一陣子沒碰就有機會忘記，像是環境的設置或是程式語法，假使有認真將這些文章記錄下來的話，到時候只要回頭看看找資料就好了，遇到一些問題就寫Blog記錄下來，下次碰到可能就忘記當初是怎麼解決的，然後就會很感謝當時的自己有留下紀錄。 好處二：內化知識找一個主題，做深入地探討、研究，過程裡可能有些你本來就懂的，或是不太懂得內容，這些似懂非懂的內容，透過寫文時有方向性地篩選與蒐集資訊，重新檢視自己的知識，深入瞭解並加深印象。 好處三：幫助學習我相信不一定要有很厲害的技術底子才有資格教人，在教學過程中對自己也是一種學習，將所學整理出一個總結，我想寫文章不只是幫助自己，只要傳達的東西能夠解決一部份人的問題那就是有價值的內容。","categories":[],"tags":[{"name":"非技術","slug":"非技術","permalink":"https://cheng-yi-ting.github.io/tags/%E9%9D%9E%E6%8A%80%E8%A1%93/"}]}]}